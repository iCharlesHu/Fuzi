<!DOCTYPE html>
<html ontouchstart="" lang="en"><head><meta charset="UTF-8"><meta name="og:site_name" content="Swift by Sundell"><link rel="canonical" href="https://www.swiftbysundell.com/articles/using-compiler-directives-in-swift"><meta name="twitter:url" content="https://www.swiftbysundell.com/articles/using-compiler-directives-in-swift"><meta name="og:url" content="https://www.swiftbysundell.com/articles/using-compiler-directives-in-swift"><title>Using compiler directives in Swift | Swift by Sundell</title><meta name="twitter:title" content="Using compiler directives in Swift | Swift by Sundell"><meta name="og:title" content="Using compiler directives in Swift | Swift by Sundell"><meta name="description" content="An overview of the tools and directives that enable us to influence how our Swift code gets compiled, and what sort of situations that each of those tools might be particularly useful in."><meta name="twitter:description" content="An overview of the tools and directives that enable us to influence how our Swift code gets compiled, and what sort of situations that each of those tools might be particularly useful in."><meta name="og:description" content="An overview of the tools and directives that enable us to influence how our Swift code gets compiled, and what sort of situations that each of those tools might be particularly useful in."><meta name="twitter:card" content="summary_large_image"><link rel="stylesheet" href="/styles.css?v=56" type="text/css"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="shortcut icon" href="/images/favicon.png" type="image/png"><link rel="alternate" href="/rss" type="application/rss+xml" title="Subscribe to Swift by Sundell"><meta name="twitter:image" content="https://www.swiftbysundell.com/images/articles/using-compiler-directives-in-swift.png"><meta name="og:image" content="https://www.swiftbysundell.com/images/articles/using-compiler-directives-in-swift.png"></head><body class="item"><header><div class="wrapper"><a href="/"><img class="logo" src="/images/logo.png" alt="Swift by Sundell"></a><p>Weekly Swift articles, podcasts and tips by <span class="inline-block"><a href="https://twitter.com/johnsundell" rel="nofollow" target="_blank">John Sundell</a>.</span></p><nav><ul><li class="selected"><a href="/articles">Weekly articles</a></li><li><a href="/basics">Basics</a></li><li><a href="/podcast">Podcast</a></li><li><a href="/tips">Tips</a></li><li><a href="/videos">Videos</a></li><li><a href="/questions">Q&amp;A</a></li><li><a href="/sponsor">Sponsorship</a></li><li class="search"><a href="/search">Search</a></li></ul></nav></div></header><article class="page wrapper article"><h1>Using compiler directives in Swift</h1><div class="metadata"><ul class="tags"><li class="variant-a"><a href="/tags/compiler">compiler</a></li><li class="variant-c"><a href="/tags/language-features">language features</a></li><li class="swift-version">Swift 5.2</li></ul><span class="date">Published on 16 Aug 2020</span></div><div class="content"><p>Even though Swift has a very strong compile-time focus when it comes to how it verifies and type-checks the code that we write, it’s still primarily used to implement runtime logic.</p><p>However, sometimes we might want to perform certain checks and run other kinds of custom logic when our code is being compiled, and although Swift doesn’t (yet) include a fully-featured macro or preprocessing system, it does ship with a few built-in compiler directives and conditions that enable us to influence the compilation process in various ways.</p><p>This week, let’s take a look at a few of those compiler directives and what sort of situations that each of them might be particularly useful in.</p><a class="sponsor" href="https://try.instabug.com/swiftbysundell?utm_source=swiftbysundell&amp;utm_medium=nativeads&amp;utm_campaign=swiftbysundell-nativeads-q320-aug-10" rel="nofollow" target="_blank"><img class="main" src="/images/sponsors/instabug-image.png" alt="Instabug"><div><p class="prefix">This ad keeps all of Swift by Sundell free for everyone. If you can, please check this sponsor out, as that directly helps support this site:</p><img class="mobile" src="/images/sponsors/instabug-image.png" alt="Instabug"><p><strong><span class="name">Instabug</span>:</strong> Catch bugs as soon as they happen and see exactly why each crash occurred. With Instabug you’ll automatically receive device data, network logs, and reproduction steps with every bug and crash report. It only takes a line of code to integrate. Start your free trial now and get three free months, <strong>exclusively for Swift by Sundell readers</strong>.</p></div></a><h2><a id="flags-and-environment-checks" href="#flags-and-environment-checks">Flags and environment checks</a></h2><p>Perhaps the most commonly used Swift compiler directive is the <code>#if</code> command, which enables us to conditionally include or exclude certain code blocks when our program is being compiled.</p><p>For example, we might use that command to check if our app is currently being compiled with its <em>debug</em> build configuration, by checking if the default <code>DEBUG</code> flag is enabled. Here we’re doing just that to conditionally print a given expression only within debug builds:</p><pre class="splash"><code><span class="s-keyword">func</span> log(<span class="s-keyword">_</span> expression: <span class="s-keyword">@autoclosure</span> () -&gt; <span class="s-type">Any</span>) {
    <span class="s-preprocessing">#if DEBUG</span>
    <span class="s-call">print</span>(<span class="s-call">expression</span>())
    <span class="s-preprocessing">#endif</span>
}</code></pre><p class="info">The <code>@autoclosure</code> attribute is used above to automatically turn any expression that was passed into our <code>log</code> function into a closure, in order to avoid evaluating it within release builds. To learn more about that attribute, check out <a href="/articles/using-autoclosure-when-designing-swift-apis">“Using @autoclosure when designing Swift APIs”</a>.</p><p>While the <code>DEBUG</code> flag provides an incredibly useful way to completely remove any code that we don’t want to include in our app’s shipping binary, sometimes we might want to use slightly more granular rules when deciding what code to include or remove.</p><p>That’s when <em>custom compilation conditions</em> can come in handy, which let us define our own, completely custom flags, which can then be enabled or disabled for different targets or build configurations. For example, let’s say that we’re currently working on a new SwiftUI-based profile view for an app, and while we’re not quite ready to ship that new implementation to the App Store, we do want to include it in internal builds of our app (such as TestFlight builds).</p><p>To make that happen, let’s define a dedicated <code>SWIFTUI_PROFILE</code> compiler condition, which we’ll only enable whenever we want to use our new SwiftUI-based profile view, and for all other builds, we’ll fall back to our previous UIKit-based implementation — like this:</p><pre class="splash"><code><span class="s-keyword">func</span> makeProfileViewController() -&gt; <span class="s-type">UIViewController</span> {
    <span class="s-preprocessing">#if SWIFTUI_PROFILE</span>
    <span class="s-keyword">return</span> <span class="s-type">UIHostingController</span>(rootView: <span class="s-type">ProfileView</span>())
    <span class="s-preprocessing">#else</span>
    <span class="s-keyword">return</span> <span class="s-type">ProfileViewController</span>()
    <span class="s-preprocessing">#endif</span>
}</code></pre><p>To toggle the above flag on or off, we can then either use the <code>Active Compilation Conditions</code> build setting in Xcode, or if we’re building a Swift Package Manager-based project, then we can enable it by passing <code>-Xswiftc SWIFTUI_PROFILE</code> to command line tools like <code>swift build</code>.</p><p class="info">To learn more about using feature flags, both compile-time and runtime ones, check out <a href="/articles/feature-flags-in-swift">“Feature flags in Swift”</a>.</p><p>Besides using various kinds of flags, another type of compilation condition that can be really useful is <code>targetEnvironment</code> — which lets us conditionally include a piece of code only when our app is being compiled for a given environment, such as <code>macCatalyst</code>, or the simulator. Here we’re using that feature to include a <code>DebugViewController</code> within an app’s tab bar when it’s being built for the iOS simulator:</p><pre class="splash"><code><span class="s-keyword">func</span> setupTabBarController(<span class="s-keyword">_</span> controller: <span class="s-type">UITabBarController</span>) {
    <span class="s-keyword">var</span> viewControllers = [<span class="s-type">UIViewController</span>]()

    <span class="s-preprocessing">#if targetEnvironment(simulator)</span>
    viewControllers.<span class="s-call">append</span>(<span class="s-type">DebugViewController</span>())
    <span class="s-preprocessing">#endif</span>

    controller.<span class="s-property">viewControllers</span> = viewControllers
}</code></pre><p>As the above code samples show, using compiler flags and the <code>targetEnvironment</code> condition is particularly useful when we want to strip out code that’s either debug-specific, or not quite ready to ship, while still enabling us to include that code within our main code base.</p><h2><a id="handling-platform-variations-within-cross-platform-code" href="#handling-platform-variations-within-cross-platform-code">Handling platform variations within cross-platform code</a></h2><p>Another type of situation in which compiler directives and conditional compilation can come in handy is whenever we’re working on a code base that supports multiple platforms — such as a cross-platform Swift package, or an app that runs on multiple Apple platforms.</p><p>As an example, let’s say that we’re working on a SwiftUI-based drawing app for iOS, macOS and tvOS, and that we’re looking to share as much code as possible between those three platforms. While many aspects of SwiftUIs overall API are identical across all of Apple’s platforms, which is a big advantage in situations like this, there are still platform-specific variations that we might need to handle.</p><p>For example, on iOS and macOS, SwiftUI supports adding a <code>DragGesture</code> to a given view, while that API is completely unavailable on tvOS — meaning that the following code won’t compile when building our app for that platform:</p><pre class="splash"><code><span class="s-keyword">struct</span> EditorView: <span class="s-type">View</span> {
    ...

    <span class="s-keyword">var</span> body: <span class="s-keyword">some</span> <span class="s-type">View</span> {
        <span class="s-type">CanvasView</span>().<span class="s-call">gesture</span>(<span class="s-type">DragGesture</span>().<span class="s-call">onChanged</span> { state <span class="s-keyword">in</span>
            ...
        })
        ...
    }
}</code></pre><p>To fix that problem, we could use the <code>os</code> compiler condition, which — just like the conditions we used earlier — enables us to only include a given piece of code when our app is being built for a specific platform. That, combined with the <code>#if</code> and <code>#else</code> directives, essentially lets us set up platform-specific branches within our cross-platform code — like this:</p><pre class="splash"><code><span class="s-keyword">struct</span> EditorView: <span class="s-type">View</span> {
    ...

    <span class="s-keyword">var</span> body: <span class="s-keyword">some</span> <span class="s-type">View</span> {
        <span class="s-preprocessing">#if os(tvOS)</span>
        <span class="s-type">CanvasView</span>()
        <span class="s-preprocessing">#else</span>
        <span class="s-type">CanvasView</span>().<span class="s-call">gesture</span>(<span class="s-type">DragGesture</span>().<span class="s-call">onChanged</span> { state <span class="s-keyword">in</span>
            ...
        })
        <span class="s-preprocessing">#endif</span>
        ...
    }
}</code></pre><p>However, while the above approach does work, it’s arguably a bit messy, and can easily lead to code that’s hard to both read and maintain — given that we’re mixing cross-platform and platform-specific code all within a single <code>View</code> implementation.</p><p>So instead, let’s see if we can isolate the above compilation condition a bit better. One way to do that would be to move it behind a dedicated abstraction, for example by implementing a custom modifier method for it, which could look something like this:</p><pre class="splash"><code><span class="s-keyword">extension</span> <span class="s-type">View</span> {
    <span class="s-keyword">func</span> addingDragGestureIfSupported(
        withHandler handler: <span class="s-keyword">@escaping</span> (<span class="s-type">CGPoint</span>) -&gt; <span class="s-type">Void</span>
    ) -&gt; <span class="s-keyword">some</span> <span class="s-type">View</span> {
        <span class="s-preprocessing">#if os(tvOS)</span>
        <span class="s-keyword">return self</span>
        <span class="s-preprocessing">#else</span>
        <span class="s-keyword">return</span> <span class="s-call">gesture</span>(<span class="s-type">DragGesture</span>().<span class="s-call">onChanged</span> { state <span class="s-keyword">in</span>
            <span class="s-call">handler</span>(state.<span class="s-property">location</span>)
        })
        <span class="s-preprocessing">#endif</span>
    }
}</code></pre><p>Since the above method signature doesn’t rely on any platform-specific types, but rather just <code>CGPoint</code> (which is available on all of Apple’s platforms as part of CoreGraphics), we can now freely call it within our cross-platform <code>EditorView</code>, and it’ll simply have no effect when our app is running on tvOS:</p><pre class="splash"><code><span class="s-keyword">struct</span> EditorView: <span class="s-type">View</span> {
    ...

    <span class="s-keyword">var</span> body: <span class="s-keyword">some</span> <span class="s-type">View</span> {
        <span class="s-type">CanvasView</span>().<span class="s-call">addingDragGestureIfSupported</span> { location <span class="s-keyword">in</span>
            ...
        }
        ...
    }
}</code></pre><p>Another option which can be good to keep in mind when dealing with the above kind of situation is to instead create multiple platform-specific variants of the same type. In our case, that could mean defining two separate <code>EditorView</code> types, one for tvOS and one for the other platforms, which could then be placed in two separate files. We’d then include the tvOS-specific file only within our app’s tvOS target, and the other one in the rest of our targets.</p><p>However, sometimes it might be more appropriate to check for the existence of a given module, rather than which platform that our code is being compiled for. That can be done using the <code>canImport</code> condition, which is particularly useful when we wish to extend an otherwise cross-platform API with features that rely on a framework that’s not universally available — such as <a href="/basics/combine">Combine</a> in this case:</p><pre class="splash"><code><span class="s-preprocessing">#if canImport(Combine)</span>
<span class="s-keyword">import</span> Combine

<span class="s-keyword">public extension</span> <span class="s-type">GitHubSearchService</span> {
    <span class="s-keyword">func</span> publisherForRepisitories(
        matching query: <span class="s-type">String</span>
    ) -&gt; <span class="s-type">AnyPublisher</span>&lt;[<span class="s-type">Repository</span>], <span class="s-type">Error</span>&gt; {
        ...
    }
}
<span class="s-preprocessing">#endif</span></code></pre><p>The benefit of using <code>canImport</code> in situations like the above is that we don’t need to manually keep track of what platforms that a given framework is available on, and it also becomes crystal clear that the code within that block is defining a framework-specific API.</p><h2><a id="emitting-warnings-and-errors" href="#emitting-warnings-and-errors">Emitting warnings and errors</a></h2><p>The idea of intentionally producing warnings and errors within a code base might at first seem a bit strange, but can be an incredibly useful tool in many kinds of situations — for example if we want to remind ourselves of a shortcut that we just took, or if we want to add a bit of extra verification to our release builds.</p><p>For example, let’s say that we’re working on a deep linking system for a shopping app, and that in order to quickly get something up and running, we’ve made a few somewhat risky assumptions within the code used to extract a product ID from a given URL. So to give ourselves a very prominent reminder to go back and fix that code before submitting it, we could use the <code>#warning</code> directive, which will cause a warning to be emitted every time that our app is being compiled:</p><pre class="splash"><code><span class="s-keyword">func</span> extractProductID(from url: <span class="s-type">URL</span>) -&gt; <span class="s-type">Product</span>.<span class="s-type">ID</span> {
    <span class="s-preprocessing">#warning</span>(<span class="s-string">"Needs validation. Also uses a hard-coded index."</span>)
    <span class="s-keyword">let</span> components = url.<span class="s-property">pathComponents</span>
    <span class="s-keyword">let</span> rawID = components[<span class="s-number">2</span>]
    <span class="s-keyword">return</span> <span class="s-type">Product</span>.<span class="s-type">ID</span>(rawID)
}</code></pre><p>Another option would be to use a classic <code>TODO</code>-style comment, perhaps in combination with a linter in order to turn such comments into warnings — but by using the above approach we’re guaranteed to always get a warning issued by the Swift compiler itself, which in turn decreases the chance that the above shortcut will be forgotten and that our code will accidentally be shipped as-is.</p><p>To further improve the prominence of the above type of warnings, we could also enable the <code>Treat Warnings as Errors</code> build setting for our app’s release configuration, which turns all warnings into actual build errors when we’re building our app for release — completely preventing us from shipping any unfinished code that’s been marked with a warning.</p><p>It’s also possible to tell the compiler to directly produce an error as well, by using the <code>#error</code> directive, for example in order to show exactly what data that needs to be manually filled in after generating a piece of boilerplate code using some form of template:</p><pre class="splash"><code><span class="s-preprocessing">#error</span>(<span class="s-string">"Enter your public API key here"</span>)
<span class="s-keyword">let</span> service = <span class="s-type">AmazingAPIClient</span>(apiKey: <span class="s-string">""</span>)
...</code></pre><p>We could also conditionally emit an error in order to make sure that none of our debug-specific compiler flags were accidentally enabled for release builds — like this:</p><pre class="splash"><code><span class="s-preprocessing">#if !DEBUG &amp;&amp; ENABLE_INTERNAL_TOOLS
#error</span>(<span class="s-string">"Internal tools must be disabled in RELEASE builds."</span>)
<span class="s-preprocessing">#endif</span></code></pre><p>Adding the above kinds of checks within our source code might seem a bit excessive, but especially if we’re often tweaking what flags that are enabled within what builds, it could be a good idea to add a bit of extra protection to prevent debugging code from being shipped within App Store builds.</p><a class="sponsor" href="https://try.instabug.com/swiftbysundell?utm_source=swiftbysundell&amp;utm_medium=nativeads&amp;utm_campaign=swiftbysundell-nativeads-q320-aug-10" rel="nofollow" target="_blank"><img class="main" src="/images/sponsors/instabug-image.png" alt="Instabug"><div><p class="prefix">This ad keeps all of Swift by Sundell free for everyone. If you can, please check this sponsor out, as that directly helps support this site:</p><img class="mobile" src="/images/sponsors/instabug-image.png" alt="Instabug"><p><strong><span class="name">Instabug</span>:</strong> Catch bugs as soon as they happen and see exactly why each crash occurred. With Instabug you’ll automatically receive device data, network logs, and reproduction steps with every bug and crash report. It only takes a line of code to integrate. Start your free trial now and get three free months, <strong>exclusively for Swift by Sundell readers</strong>.</p></div></a><h2><a id="conclusion" href="#conclusion">Conclusion</a></h2><p>While Swift’s compiler directives might currently be quite limited compared to what some other languages offer, they still enable us to perform a fair amount of custom compile-time checks, and to create various kinds of conditional branches within our code.</p><p>However, while each of the directives that we took a look at in this article are useful within certain kinds of situations, it’s also important not to over-use them, as each time that we introduce a conditionally compiled code block, we’re essentially adding a new variant of our app that needs to be constantly tested and maintained.</p><p>Got questions, comments or feedback? You’re always welcome to contact me either via <a href="https://twitter.com/johnsundell">Twitter</a> or <a href="/contact">email</a>.</p><p>Thanks for reading! 🚀</p></div><ul class="actions"><li class="share"><a href="https://twitter.com/intent/tweet?via=johnsundell&amp;text=%E2%80%9CUsing%20compiler%20directives%20in%20Swift%E2%80%9D&amp;url=https%3A//www.swiftbysundell.com/articles/using-compiler-directives-in-swift" rel="nofollow">Share this article on Twitter</a></li></ul><div class="related-content"><div class="float-container"><h2>More on similar topics</h2><a class="browse-all" href="/tags">Browse all content by tag</a></div><ul class="item-list grid compact"><li><a aria-label="Overriding self with a weak reference" href="/tips/overriding-self-with-a-weak-reference"><article class="tips"><span class="type">Tip</span><h1>Overriding self with a weak reference</h1></article></a></li><li><a aria-label="Omitting the return keyword" href="/tips/omitting-the-return-keyword"><article class="tips"><span class="type">Tip</span><h1>Omitting the return keyword</h1></article></a></li><li><a aria-label="Mixing enums with other Swift types" href="/articles/mixing-enums-with-other-swift-types"><article class="article"><span class="type">Article</span><h1>Mixing enums with other Swift types</h1></article></a></li></ul></div></article><a aria-label="A deep dive into Swift’s function builders" class="pagination previous" href="/articles/deep-dive-into-swift-function-builders"><b>Previous:</b> A deep dive into Swift’s function builders</a><footer><p>Copyright © Sundell sp. z o.o. 2020.</p><p>Built in Swift using <a href="https://github.com/johnsundell/publish">Publish</a>.</p><p><a href="https://twitter.com/swiftbysundell" rel="nofollow" target="_blank">Twitter</a> | <a href="/subscribe">RSS</a> | <a href="/contact">Contact</a></p></footer></body></html>
<head><meta charset="UTF-8"><meta name="og:site_name" content="Swift by Sundell"><link rel="canonical" href="https://www.swiftbysundell.com/articles/using-compiler-directives-in-swift"><meta name="twitter:url" content="https://www.swiftbysundell.com/articles/using-compiler-directives-in-swift"><meta name="og:url" content="https://www.swiftbysundell.com/articles/using-compiler-directives-in-swift"><title>Using compiler directives in Swift | Swift by Sundell</title><meta name="twitter:title" content="Using compiler directives in Swift | Swift by Sundell"><meta name="og:title" content="Using compiler directives in Swift | Swift by Sundell"><meta name="description" content="An overview of the tools and directives that enable us to influence how our Swift code gets compiled, and what sort of situations that each of those tools might be particularly useful in."><meta name="twitter:description" content="An overview of the tools and directives that enable us to influence how our Swift code gets compiled, and what sort of situations that each of those tools might be particularly useful in."><meta name="og:description" content="An overview of the tools and directives that enable us to influence how our Swift code gets compiled, and what sort of situations that each of those tools might be particularly useful in."><meta name="twitter:card" content="summary_large_image"><link rel="stylesheet" href="/styles.css?v=56" type="text/css"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="shortcut icon" href="/images/favicon.png" type="image/png"><link rel="alternate" href="/rss" type="application/rss+xml" title="Subscribe to Swift by Sundell"><meta name="twitter:image" content="https://www.swiftbysundell.com/images/articles/using-compiler-directives-in-swift.png"><meta name="og:image" content="https://www.swiftbysundell.com/images/articles/using-compiler-directives-in-swift.png"></head>
<meta charset="UTF-8">
<meta name="og:site_name" content="Swift by Sundell">
<link rel="canonical" href="https://www.swiftbysundell.com/articles/using-compiler-directives-in-swift">
<meta name="twitter:url" content="https://www.swiftbysundell.com/articles/using-compiler-directives-in-swift">
<meta name="og:url" content="https://www.swiftbysundell.com/articles/using-compiler-directives-in-swift">
<title>Using compiler directives in Swift | Swift by Sundell</title>
<meta name="twitter:title" content="Using compiler directives in Swift | Swift by Sundell">
<meta name="og:title" content="Using compiler directives in Swift | Swift by Sundell">
<meta name="description" content="An overview of the tools and directives that enable us to influence how our Swift code gets compiled, and what sort of situations that each of those tools might be particularly useful in.">
<meta name="twitter:description" content="An overview of the tools and directives that enable us to influence how our Swift code gets compiled, and what sort of situations that each of those tools might be particularly useful in.">
<meta name="og:description" content="An overview of the tools and directives that enable us to influence how our Swift code gets compiled, and what sort of situations that each of those tools might be particularly useful in.">
<meta name="twitter:card" content="summary_large_image">
<link rel="stylesheet" href="/styles.css?v=56" type="text/css">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<link rel="shortcut icon" href="/images/favicon.png" type="image/png">
<link rel="alternate" href="/rss" type="application/rss+xml" title="Subscribe to Swift by Sundell">
<meta name="twitter:image" content="https://www.swiftbysundell.com/images/articles/using-compiler-directives-in-swift.png">
<meta name="og:image" content="https://www.swiftbysundell.com/images/articles/using-compiler-directives-in-swift.png">
<head><meta charset="UTF-8"><meta name="og:site_name" content="Swift by Sundell"><link rel="canonical" href="https://www.swiftbysundell.com/articles/using-compiler-directives-in-swift"><meta name="twitter:url" content="https://www.swiftbysundell.com/articles/using-compiler-directives-in-swift"><meta name="og:url" content="https://www.swiftbysundell.com/articles/using-compiler-directives-in-swift"><title>Using compiler directives in Swift | Swift by Sundell</title><meta name="twitter:title" content="Using compiler directives in Swift | Swift by Sundell"><meta name="og:title" content="Using compiler directives in Swift | Swift by Sundell"><meta name="description" content="An overview of the tools and directives that enable us to influence how our Swift code gets compiled, and what sort of situations that each of those tools might be particularly useful in."><meta name="twitter:description" content="An overview of the tools and directives that enable us to influence how our Swift code gets compiled, and what sort of situations that each of those tools might be particularly useful in."><meta name="og:description" content="An overview of the tools and directives that enable us to influence how our Swift code gets compiled, and what sort of situations that each of those tools might be particularly useful in."><meta name="twitter:card" content="summary_large_image"><link rel="stylesheet" href="/styles.css?v=56" type="text/css"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="shortcut icon" href="/images/favicon.png" type="image/png"><link rel="alternate" href="/rss" type="application/rss+xml" title="Subscribe to Swift by Sundell"><meta name="twitter:image" content="https://www.swiftbysundell.com/images/articles/using-compiler-directives-in-swift.png"><meta name="og:image" content="https://www.swiftbysundell.com/images/articles/using-compiler-directives-in-swift.png"></head>
<body class="item"><header><div class="wrapper"><a href="/"><img class="logo" src="/images/logo.png" alt="Swift by Sundell"></a><p>Weekly Swift articles, podcasts and tips by <span class="inline-block"><a href="https://twitter.com/johnsundell" rel="nofollow" target="_blank">John Sundell</a>.</span></p><nav><ul><li class="selected"><a href="/articles">Weekly articles</a></li><li><a href="/basics">Basics</a></li><li><a href="/podcast">Podcast</a></li><li><a href="/tips">Tips</a></li><li><a href="/videos">Videos</a></li><li><a href="/questions">Q&amp;A</a></li><li><a href="/sponsor">Sponsorship</a></li><li class="search"><a href="/search">Search</a></li></ul></nav></div></header><article class="page wrapper article"><h1>Using compiler directives in Swift</h1><div class="metadata"><ul class="tags"><li class="variant-a"><a href="/tags/compiler">compiler</a></li><li class="variant-c"><a href="/tags/language-features">language features</a></li><li class="swift-version">Swift 5.2</li></ul><span class="date">Published on 16 Aug 2020</span></div><div class="content"><p>Even though Swift has a very strong compile-time focus when it comes to how it verifies and type-checks the code that we write, it’s still primarily used to implement runtime logic.</p><p>However, sometimes we might want to perform certain checks and run other kinds of custom logic when our code is being compiled, and although Swift doesn’t (yet) include a fully-featured macro or preprocessing system, it does ship with a few built-in compiler directives and conditions that enable us to influence the compilation process in various ways.</p><p>This week, let’s take a look at a few of those compiler directives and what sort of situations that each of them might be particularly useful in.</p><a class="sponsor" href="https://try.instabug.com/swiftbysundell?utm_source=swiftbysundell&amp;utm_medium=nativeads&amp;utm_campaign=swiftbysundell-nativeads-q320-aug-10" rel="nofollow" target="_blank"><img class="main" src="/images/sponsors/instabug-image.png" alt="Instabug"><div><p class="prefix">This ad keeps all of Swift by Sundell free for everyone. If you can, please check this sponsor out, as that directly helps support this site:</p><img class="mobile" src="/images/sponsors/instabug-image.png" alt="Instabug"><p><strong><span class="name">Instabug</span>:</strong> Catch bugs as soon as they happen and see exactly why each crash occurred. With Instabug you’ll automatically receive device data, network logs, and reproduction steps with every bug and crash report. It only takes a line of code to integrate. Start your free trial now and get three free months, <strong>exclusively for Swift by Sundell readers</strong>.</p></div></a><h2><a id="flags-and-environment-checks" href="#flags-and-environment-checks">Flags and environment checks</a></h2><p>Perhaps the most commonly used Swift compiler directive is the <code>#if</code> command, which enables us to conditionally include or exclude certain code blocks when our program is being compiled.</p><p>For example, we might use that command to check if our app is currently being compiled with its <em>debug</em> build configuration, by checking if the default <code>DEBUG</code> flag is enabled. Here we’re doing just that to conditionally print a given expression only within debug builds:</p><pre class="splash"><code><span class="s-keyword">func</span> log(<span class="s-keyword">_</span> expression: <span class="s-keyword">@autoclosure</span> () -&gt; <span class="s-type">Any</span>) {
    <span class="s-preprocessing">#if DEBUG</span>
    <span class="s-call">print</span>(<span class="s-call">expression</span>())
    <span class="s-preprocessing">#endif</span>
}</code></pre><p class="info">The <code>@autoclosure</code> attribute is used above to automatically turn any expression that was passed into our <code>log</code> function into a closure, in order to avoid evaluating it within release builds. To learn more about that attribute, check out <a href="/articles/using-autoclosure-when-designing-swift-apis">“Using @autoclosure when designing Swift APIs”</a>.</p><p>While the <code>DEBUG</code> flag provides an incredibly useful way to completely remove any code that we don’t want to include in our app’s shipping binary, sometimes we might want to use slightly more granular rules when deciding what code to include or remove.</p><p>That’s when <em>custom compilation conditions</em> can come in handy, which let us define our own, completely custom flags, which can then be enabled or disabled for different targets or build configurations. For example, let’s say that we’re currently working on a new SwiftUI-based profile view for an app, and while we’re not quite ready to ship that new implementation to the App Store, we do want to include it in internal builds of our app (such as TestFlight builds).</p><p>To make that happen, let’s define a dedicated <code>SWIFTUI_PROFILE</code> compiler condition, which we’ll only enable whenever we want to use our new SwiftUI-based profile view, and for all other builds, we’ll fall back to our previous UIKit-based implementation — like this:</p><pre class="splash"><code><span class="s-keyword">func</span> makeProfileViewController() -&gt; <span class="s-type">UIViewController</span> {
    <span class="s-preprocessing">#if SWIFTUI_PROFILE</span>
    <span class="s-keyword">return</span> <span class="s-type">UIHostingController</span>(rootView: <span class="s-type">ProfileView</span>())
    <span class="s-preprocessing">#else</span>
    <span class="s-keyword">return</span> <span class="s-type">ProfileViewController</span>()
    <span class="s-preprocessing">#endif</span>
}</code></pre><p>To toggle the above flag on or off, we can then either use the <code>Active Compilation Conditions</code> build setting in Xcode, or if we’re building a Swift Package Manager-based project, then we can enable it by passing <code>-Xswiftc SWIFTUI_PROFILE</code> to command line tools like <code>swift build</code>.</p><p class="info">To learn more about using feature flags, both compile-time and runtime ones, check out <a href="/articles/feature-flags-in-swift">“Feature flags in Swift”</a>.</p><p>Besides using various kinds of flags, another type of compilation condition that can be really useful is <code>targetEnvironment</code> — which lets us conditionally include a piece of code only when our app is being compiled for a given environment, such as <code>macCatalyst</code>, or the simulator. Here we’re using that feature to include a <code>DebugViewController</code> within an app’s tab bar when it’s being built for the iOS simulator:</p><pre class="splash"><code><span class="s-keyword">func</span> setupTabBarController(<span class="s-keyword">_</span> controller: <span class="s-type">UITabBarController</span>) {
    <span class="s-keyword">var</span> viewControllers = [<span class="s-type">UIViewController</span>]()

    <span class="s-preprocessing">#if targetEnvironment(simulator)</span>
    viewControllers.<span class="s-call">append</span>(<span class="s-type">DebugViewController</span>())
    <span class="s-preprocessing">#endif</span>

    controller.<span class="s-property">viewControllers</span> = viewControllers
}</code></pre><p>As the above code samples show, using compiler flags and the <code>targetEnvironment</code> condition is particularly useful when we want to strip out code that’s either debug-specific, or not quite ready to ship, while still enabling us to include that code within our main code base.</p><h2><a id="handling-platform-variations-within-cross-platform-code" href="#handling-platform-variations-within-cross-platform-code">Handling platform variations within cross-platform code</a></h2><p>Another type of situation in which compiler directives and conditional compilation can come in handy is whenever we’re working on a code base that supports multiple platforms — such as a cross-platform Swift package, or an app that runs on multiple Apple platforms.</p><p>As an example, let’s say that we’re working on a SwiftUI-based drawing app for iOS, macOS and tvOS, and that we’re looking to share as much code as possible between those three platforms. While many aspects of SwiftUIs overall API are identical across all of Apple’s platforms, which is a big advantage in situations like this, there are still platform-specific variations that we might need to handle.</p><p>For example, on iOS and macOS, SwiftUI supports adding a <code>DragGesture</code> to a given view, while that API is completely unavailable on tvOS — meaning that the following code won’t compile when building our app for that platform:</p><pre class="splash"><code><span class="s-keyword">struct</span> EditorView: <span class="s-type">View</span> {
    ...

    <span class="s-keyword">var</span> body: <span class="s-keyword">some</span> <span class="s-type">View</span> {
        <span class="s-type">CanvasView</span>().<span class="s-call">gesture</span>(<span class="s-type">DragGesture</span>().<span class="s-call">onChanged</span> { state <span class="s-keyword">in</span>
            ...
        })
        ...
    }
}</code></pre><p>To fix that problem, we could use the <code>os</code> compiler condition, which — just like the conditions we used earlier — enables us to only include a given piece of code when our app is being built for a specific platform. That, combined with the <code>#if</code> and <code>#else</code> directives, essentially lets us set up platform-specific branches within our cross-platform code — like this:</p><pre class="splash"><code><span class="s-keyword">struct</span> EditorView: <span class="s-type">View</span> {
    ...

    <span class="s-keyword">var</span> body: <span class="s-keyword">some</span> <span class="s-type">View</span> {
        <span class="s-preprocessing">#if os(tvOS)</span>
        <span class="s-type">CanvasView</span>()
        <span class="s-preprocessing">#else</span>
        <span class="s-type">CanvasView</span>().<span class="s-call">gesture</span>(<span class="s-type">DragGesture</span>().<span class="s-call">onChanged</span> { state <span class="s-keyword">in</span>
            ...
        })
        <span class="s-preprocessing">#endif</span>
        ...
    }
}</code></pre><p>However, while the above approach does work, it’s arguably a bit messy, and can easily lead to code that’s hard to both read and maintain — given that we’re mixing cross-platform and platform-specific code all within a single <code>View</code> implementation.</p><p>So instead, let’s see if we can isolate the above compilation condition a bit better. One way to do that would be to move it behind a dedicated abstraction, for example by implementing a custom modifier method for it, which could look something like this:</p><pre class="splash"><code><span class="s-keyword">extension</span> <span class="s-type">View</span> {
    <span class="s-keyword">func</span> addingDragGestureIfSupported(
        withHandler handler: <span class="s-keyword">@escaping</span> (<span class="s-type">CGPoint</span>) -&gt; <span class="s-type">Void</span>
    ) -&gt; <span class="s-keyword">some</span> <span class="s-type">View</span> {
        <span class="s-preprocessing">#if os(tvOS)</span>
        <span class="s-keyword">return self</span>
        <span class="s-preprocessing">#else</span>
        <span class="s-keyword">return</span> <span class="s-call">gesture</span>(<span class="s-type">DragGesture</span>().<span class="s-call">onChanged</span> { state <span class="s-keyword">in</span>
            <span class="s-call">handler</span>(state.<span class="s-property">location</span>)
        })
        <span class="s-preprocessing">#endif</span>
    }
}</code></pre><p>Since the above method signature doesn’t rely on any platform-specific types, but rather just <code>CGPoint</code> (which is available on all of Apple’s platforms as part of CoreGraphics), we can now freely call it within our cross-platform <code>EditorView</code>, and it’ll simply have no effect when our app is running on tvOS:</p><pre class="splash"><code><span class="s-keyword">struct</span> EditorView: <span class="s-type">View</span> {
    ...

    <span class="s-keyword">var</span> body: <span class="s-keyword">some</span> <span class="s-type">View</span> {
        <span class="s-type">CanvasView</span>().<span class="s-call">addingDragGestureIfSupported</span> { location <span class="s-keyword">in</span>
            ...
        }
        ...
    }
}</code></pre><p>Another option which can be good to keep in mind when dealing with the above kind of situation is to instead create multiple platform-specific variants of the same type. In our case, that could mean defining two separate <code>EditorView</code> types, one for tvOS and one for the other platforms, which could then be placed in two separate files. We’d then include the tvOS-specific file only within our app’s tvOS target, and the other one in the rest of our targets.</p><p>However, sometimes it might be more appropriate to check for the existence of a given module, rather than which platform that our code is being compiled for. That can be done using the <code>canImport</code> condition, which is particularly useful when we wish to extend an otherwise cross-platform API with features that rely on a framework that’s not universally available — such as <a href="/basics/combine">Combine</a> in this case:</p><pre class="splash"><code><span class="s-preprocessing">#if canImport(Combine)</span>
<span class="s-keyword">import</span> Combine

<span class="s-keyword">public extension</span> <span class="s-type">GitHubSearchService</span> {
    <span class="s-keyword">func</span> publisherForRepisitories(
        matching query: <span class="s-type">String</span>
    ) -&gt; <span class="s-type">AnyPublisher</span>&lt;[<span class="s-type">Repository</span>], <span class="s-type">Error</span>&gt; {
        ...
    }
}
<span class="s-preprocessing">#endif</span></code></pre><p>The benefit of using <code>canImport</code> in situations like the above is that we don’t need to manually keep track of what platforms that a given framework is available on, and it also becomes crystal clear that the code within that block is defining a framework-specific API.</p><h2><a id="emitting-warnings-and-errors" href="#emitting-warnings-and-errors">Emitting warnings and errors</a></h2><p>The idea of intentionally producing warnings and errors within a code base might at first seem a bit strange, but can be an incredibly useful tool in many kinds of situations — for example if we want to remind ourselves of a shortcut that we just took, or if we want to add a bit of extra verification to our release builds.</p><p>For example, let’s say that we’re working on a deep linking system for a shopping app, and that in order to quickly get something up and running, we’ve made a few somewhat risky assumptions within the code used to extract a product ID from a given URL. So to give ourselves a very prominent reminder to go back and fix that code before submitting it, we could use the <code>#warning</code> directive, which will cause a warning to be emitted every time that our app is being compiled:</p><pre class="splash"><code><span class="s-keyword">func</span> extractProductID(from url: <span class="s-type">URL</span>) -&gt; <span class="s-type">Product</span>.<span class="s-type">ID</span> {
    <span class="s-preprocessing">#warning</span>(<span class="s-string">"Needs validation. Also uses a hard-coded index."</span>)
    <span class="s-keyword">let</span> components = url.<span class="s-property">pathComponents</span>
    <span class="s-keyword">let</span> rawID = components[<span class="s-number">2</span>]
    <span class="s-keyword">return</span> <span class="s-type">Product</span>.<span class="s-type">ID</span>(rawID)
}</code></pre><p>Another option would be to use a classic <code>TODO</code>-style comment, perhaps in combination with a linter in order to turn such comments into warnings — but by using the above approach we’re guaranteed to always get a warning issued by the Swift compiler itself, which in turn decreases the chance that the above shortcut will be forgotten and that our code will accidentally be shipped as-is.</p><p>To further improve the prominence of the above type of warnings, we could also enable the <code>Treat Warnings as Errors</code> build setting for our app’s release configuration, which turns all warnings into actual build errors when we’re building our app for release — completely preventing us from shipping any unfinished code that’s been marked with a warning.</p><p>It’s also possible to tell the compiler to directly produce an error as well, by using the <code>#error</code> directive, for example in order to show exactly what data that needs to be manually filled in after generating a piece of boilerplate code using some form of template:</p><pre class="splash"><code><span class="s-preprocessing">#error</span>(<span class="s-string">"Enter your public API key here"</span>)
<span class="s-keyword">let</span> service = <span class="s-type">AmazingAPIClient</span>(apiKey: <span class="s-string">""</span>)
...</code></pre><p>We could also conditionally emit an error in order to make sure that none of our debug-specific compiler flags were accidentally enabled for release builds — like this:</p><pre class="splash"><code><span class="s-preprocessing">#if !DEBUG &amp;&amp; ENABLE_INTERNAL_TOOLS
#error</span>(<span class="s-string">"Internal tools must be disabled in RELEASE builds."</span>)
<span class="s-preprocessing">#endif</span></code></pre><p>Adding the above kinds of checks within our source code might seem a bit excessive, but especially if we’re often tweaking what flags that are enabled within what builds, it could be a good idea to add a bit of extra protection to prevent debugging code from being shipped within App Store builds.</p><a class="sponsor" href="https://try.instabug.com/swiftbysundell?utm_source=swiftbysundell&amp;utm_medium=nativeads&amp;utm_campaign=swiftbysundell-nativeads-q320-aug-10" rel="nofollow" target="_blank"><img class="main" src="/images/sponsors/instabug-image.png" alt="Instabug"><div><p class="prefix">This ad keeps all of Swift by Sundell free for everyone. If you can, please check this sponsor out, as that directly helps support this site:</p><img class="mobile" src="/images/sponsors/instabug-image.png" alt="Instabug"><p><strong><span class="name">Instabug</span>:</strong> Catch bugs as soon as they happen and see exactly why each crash occurred. With Instabug you’ll automatically receive device data, network logs, and reproduction steps with every bug and crash report. It only takes a line of code to integrate. Start your free trial now and get three free months, <strong>exclusively for Swift by Sundell readers</strong>.</p></div></a><h2><a id="conclusion" href="#conclusion">Conclusion</a></h2><p>While Swift’s compiler directives might currently be quite limited compared to what some other languages offer, they still enable us to perform a fair amount of custom compile-time checks, and to create various kinds of conditional branches within our code.</p><p>However, while each of the directives that we took a look at in this article are useful within certain kinds of situations, it’s also important not to over-use them, as each time that we introduce a conditionally compiled code block, we’re essentially adding a new variant of our app that needs to be constantly tested and maintained.</p><p>Got questions, comments or feedback? You’re always welcome to contact me either via <a href="https://twitter.com/johnsundell">Twitter</a> or <a href="/contact">email</a>.</p><p>Thanks for reading! 🚀</p></div><ul class="actions"><li class="share"><a href="https://twitter.com/intent/tweet?via=johnsundell&amp;text=%E2%80%9CUsing%20compiler%20directives%20in%20Swift%E2%80%9D&amp;url=https%3A//www.swiftbysundell.com/articles/using-compiler-directives-in-swift" rel="nofollow">Share this article on Twitter</a></li></ul><div class="related-content"><div class="float-container"><h2>More on similar topics</h2><a class="browse-all" href="/tags">Browse all content by tag</a></div><ul class="item-list grid compact"><li><a aria-label="Overriding self with a weak reference" href="/tips/overriding-self-with-a-weak-reference"><article class="tips"><span class="type">Tip</span><h1>Overriding self with a weak reference</h1></article></a></li><li><a aria-label="Omitting the return keyword" href="/tips/omitting-the-return-keyword"><article class="tips"><span class="type">Tip</span><h1>Omitting the return keyword</h1></article></a></li><li><a aria-label="Mixing enums with other Swift types" href="/articles/mixing-enums-with-other-swift-types"><article class="article"><span class="type">Article</span><h1>Mixing enums with other Swift types</h1></article></a></li></ul></div></article><a aria-label="A deep dive into Swift’s function builders" class="pagination previous" href="/articles/deep-dive-into-swift-function-builders"><b>Previous:</b> A deep dive into Swift’s function builders</a><footer><p>Copyright © Sundell sp. z o.o. 2020.</p><p>Built in Swift using <a href="https://github.com/johnsundell/publish">Publish</a>.</p><p><a href="https://twitter.com/swiftbysundell" rel="nofollow" target="_blank">Twitter</a> | <a href="/subscribe">RSS</a> | <a href="/contact">Contact</a></p></footer></body>
<header><div class="wrapper"><a href="/"><img class="logo" src="/images/logo.png" alt="Swift by Sundell"></a><p>Weekly Swift articles, podcasts and tips by <span class="inline-block"><a href="https://twitter.com/johnsundell" rel="nofollow" target="_blank">John Sundell</a>.</span></p><nav><ul><li class="selected"><a href="/articles">Weekly articles</a></li><li><a href="/basics">Basics</a></li><li><a href="/podcast">Podcast</a></li><li><a href="/tips">Tips</a></li><li><a href="/videos">Videos</a></li><li><a href="/questions">Q&amp;A</a></li><li><a href="/sponsor">Sponsorship</a></li><li class="search"><a href="/search">Search</a></li></ul></nav></div></header>
<article class="page wrapper article"><h1>Using compiler directives in Swift</h1><div class="metadata"><ul class="tags"><li class="variant-a"><a href="/tags/compiler">compiler</a></li><li class="variant-c"><a href="/tags/language-features">language features</a></li><li class="swift-version">Swift 5.2</li></ul><span class="date">Published on 16 Aug 2020</span></div><div class="content"><p>Even though Swift has a very strong compile-time focus when it comes to how it verifies and type-checks the code that we write, it’s still primarily used to implement runtime logic.</p><p>However, sometimes we might want to perform certain checks and run other kinds of custom logic when our code is being compiled, and although Swift doesn’t (yet) include a fully-featured macro or preprocessing system, it does ship with a few built-in compiler directives and conditions that enable us to influence the compilation process in various ways.</p><p>This week, let’s take a look at a few of those compiler directives and what sort of situations that each of them might be particularly useful in.</p><a class="sponsor" href="https://try.instabug.com/swiftbysundell?utm_source=swiftbysundell&amp;utm_medium=nativeads&amp;utm_campaign=swiftbysundell-nativeads-q320-aug-10" rel="nofollow" target="_blank"><img class="main" src="/images/sponsors/instabug-image.png" alt="Instabug"><div><p class="prefix">This ad keeps all of Swift by Sundell free for everyone. If you can, please check this sponsor out, as that directly helps support this site:</p><img class="mobile" src="/images/sponsors/instabug-image.png" alt="Instabug"><p><strong><span class="name">Instabug</span>:</strong> Catch bugs as soon as they happen and see exactly why each crash occurred. With Instabug you’ll automatically receive device data, network logs, and reproduction steps with every bug and crash report. It only takes a line of code to integrate. Start your free trial now and get three free months, <strong>exclusively for Swift by Sundell readers</strong>.</p></div></a><h2><a id="flags-and-environment-checks" href="#flags-and-environment-checks">Flags and environment checks</a></h2><p>Perhaps the most commonly used Swift compiler directive is the <code>#if</code> command, which enables us to conditionally include or exclude certain code blocks when our program is being compiled.</p><p>For example, we might use that command to check if our app is currently being compiled with its <em>debug</em> build configuration, by checking if the default <code>DEBUG</code> flag is enabled. Here we’re doing just that to conditionally print a given expression only within debug builds:</p><pre class="splash"><code><span class="s-keyword">func</span> log(<span class="s-keyword">_</span> expression: <span class="s-keyword">@autoclosure</span> () -&gt; <span class="s-type">Any</span>) {
    <span class="s-preprocessing">#if DEBUG</span>
    <span class="s-call">print</span>(<span class="s-call">expression</span>())
    <span class="s-preprocessing">#endif</span>
}</code></pre><p class="info">The <code>@autoclosure</code> attribute is used above to automatically turn any expression that was passed into our <code>log</code> function into a closure, in order to avoid evaluating it within release builds. To learn more about that attribute, check out <a href="/articles/using-autoclosure-when-designing-swift-apis">“Using @autoclosure when designing Swift APIs”</a>.</p><p>While the <code>DEBUG</code> flag provides an incredibly useful way to completely remove any code that we don’t want to include in our app’s shipping binary, sometimes we might want to use slightly more granular rules when deciding what code to include or remove.</p><p>That’s when <em>custom compilation conditions</em> can come in handy, which let us define our own, completely custom flags, which can then be enabled or disabled for different targets or build configurations. For example, let’s say that we’re currently working on a new SwiftUI-based profile view for an app, and while we’re not quite ready to ship that new implementation to the App Store, we do want to include it in internal builds of our app (such as TestFlight builds).</p><p>To make that happen, let’s define a dedicated <code>SWIFTUI_PROFILE</code> compiler condition, which we’ll only enable whenever we want to use our new SwiftUI-based profile view, and for all other builds, we’ll fall back to our previous UIKit-based implementation — like this:</p><pre class="splash"><code><span class="s-keyword">func</span> makeProfileViewController() -&gt; <span class="s-type">UIViewController</span> {
    <span class="s-preprocessing">#if SWIFTUI_PROFILE</span>
    <span class="s-keyword">return</span> <span class="s-type">UIHostingController</span>(rootView: <span class="s-type">ProfileView</span>())
    <span class="s-preprocessing">#else</span>
    <span class="s-keyword">return</span> <span class="s-type">ProfileViewController</span>()
    <span class="s-preprocessing">#endif</span>
}</code></pre><p>To toggle the above flag on or off, we can then either use the <code>Active Compilation Conditions</code> build setting in Xcode, or if we’re building a Swift Package Manager-based project, then we can enable it by passing <code>-Xswiftc SWIFTUI_PROFILE</code> to command line tools like <code>swift build</code>.</p><p class="info">To learn more about using feature flags, both compile-time and runtime ones, check out <a href="/articles/feature-flags-in-swift">“Feature flags in Swift”</a>.</p><p>Besides using various kinds of flags, another type of compilation condition that can be really useful is <code>targetEnvironment</code> — which lets us conditionally include a piece of code only when our app is being compiled for a given environment, such as <code>macCatalyst</code>, or the simulator. Here we’re using that feature to include a <code>DebugViewController</code> within an app’s tab bar when it’s being built for the iOS simulator:</p><pre class="splash"><code><span class="s-keyword">func</span> setupTabBarController(<span class="s-keyword">_</span> controller: <span class="s-type">UITabBarController</span>) {
    <span class="s-keyword">var</span> viewControllers = [<span class="s-type">UIViewController</span>]()

    <span class="s-preprocessing">#if targetEnvironment(simulator)</span>
    viewControllers.<span class="s-call">append</span>(<span class="s-type">DebugViewController</span>())
    <span class="s-preprocessing">#endif</span>

    controller.<span class="s-property">viewControllers</span> = viewControllers
}</code></pre><p>As the above code samples show, using compiler flags and the <code>targetEnvironment</code> condition is particularly useful when we want to strip out code that’s either debug-specific, or not quite ready to ship, while still enabling us to include that code within our main code base.</p><h2><a id="handling-platform-variations-within-cross-platform-code" href="#handling-platform-variations-within-cross-platform-code">Handling platform variations within cross-platform code</a></h2><p>Another type of situation in which compiler directives and conditional compilation can come in handy is whenever we’re working on a code base that supports multiple platforms — such as a cross-platform Swift package, or an app that runs on multiple Apple platforms.</p><p>As an example, let’s say that we’re working on a SwiftUI-based drawing app for iOS, macOS and tvOS, and that we’re looking to share as much code as possible between those three platforms. While many aspects of SwiftUIs overall API are identical across all of Apple’s platforms, which is a big advantage in situations like this, there are still platform-specific variations that we might need to handle.</p><p>For example, on iOS and macOS, SwiftUI supports adding a <code>DragGesture</code> to a given view, while that API is completely unavailable on tvOS — meaning that the following code won’t compile when building our app for that platform:</p><pre class="splash"><code><span class="s-keyword">struct</span> EditorView: <span class="s-type">View</span> {
    ...

    <span class="s-keyword">var</span> body: <span class="s-keyword">some</span> <span class="s-type">View</span> {
        <span class="s-type">CanvasView</span>().<span class="s-call">gesture</span>(<span class="s-type">DragGesture</span>().<span class="s-call">onChanged</span> { state <span class="s-keyword">in</span>
            ...
        })
        ...
    }
}</code></pre><p>To fix that problem, we could use the <code>os</code> compiler condition, which — just like the conditions we used earlier — enables us to only include a given piece of code when our app is being built for a specific platform. That, combined with the <code>#if</code> and <code>#else</code> directives, essentially lets us set up platform-specific branches within our cross-platform code — like this:</p><pre class="splash"><code><span class="s-keyword">struct</span> EditorView: <span class="s-type">View</span> {
    ...

    <span class="s-keyword">var</span> body: <span class="s-keyword">some</span> <span class="s-type">View</span> {
        <span class="s-preprocessing">#if os(tvOS)</span>
        <span class="s-type">CanvasView</span>()
        <span class="s-preprocessing">#else</span>
        <span class="s-type">CanvasView</span>().<span class="s-call">gesture</span>(<span class="s-type">DragGesture</span>().<span class="s-call">onChanged</span> { state <span class="s-keyword">in</span>
            ...
        })
        <span class="s-preprocessing">#endif</span>
        ...
    }
}</code></pre><p>However, while the above approach does work, it’s arguably a bit messy, and can easily lead to code that’s hard to both read and maintain — given that we’re mixing cross-platform and platform-specific code all within a single <code>View</code> implementation.</p><p>So instead, let’s see if we can isolate the above compilation condition a bit better. One way to do that would be to move it behind a dedicated abstraction, for example by implementing a custom modifier method for it, which could look something like this:</p><pre class="splash"><code><span class="s-keyword">extension</span> <span class="s-type">View</span> {
    <span class="s-keyword">func</span> addingDragGestureIfSupported(
        withHandler handler: <span class="s-keyword">@escaping</span> (<span class="s-type">CGPoint</span>) -&gt; <span class="s-type">Void</span>
    ) -&gt; <span class="s-keyword">some</span> <span class="s-type">View</span> {
        <span class="s-preprocessing">#if os(tvOS)</span>
        <span class="s-keyword">return self</span>
        <span class="s-preprocessing">#else</span>
        <span class="s-keyword">return</span> <span class="s-call">gesture</span>(<span class="s-type">DragGesture</span>().<span class="s-call">onChanged</span> { state <span class="s-keyword">in</span>
            <span class="s-call">handler</span>(state.<span class="s-property">location</span>)
        })
        <span class="s-preprocessing">#endif</span>
    }
}</code></pre><p>Since the above method signature doesn’t rely on any platform-specific types, but rather just <code>CGPoint</code> (which is available on all of Apple’s platforms as part of CoreGraphics), we can now freely call it within our cross-platform <code>EditorView</code>, and it’ll simply have no effect when our app is running on tvOS:</p><pre class="splash"><code><span class="s-keyword">struct</span> EditorView: <span class="s-type">View</span> {
    ...

    <span class="s-keyword">var</span> body: <span class="s-keyword">some</span> <span class="s-type">View</span> {
        <span class="s-type">CanvasView</span>().<span class="s-call">addingDragGestureIfSupported</span> { location <span class="s-keyword">in</span>
            ...
        }
        ...
    }
}</code></pre><p>Another option which can be good to keep in mind when dealing with the above kind of situation is to instead create multiple platform-specific variants of the same type. In our case, that could mean defining two separate <code>EditorView</code> types, one for tvOS and one for the other platforms, which could then be placed in two separate files. We’d then include the tvOS-specific file only within our app’s tvOS target, and the other one in the rest of our targets.</p><p>However, sometimes it might be more appropriate to check for the existence of a given module, rather than which platform that our code is being compiled for. That can be done using the <code>canImport</code> condition, which is particularly useful when we wish to extend an otherwise cross-platform API with features that rely on a framework that’s not universally available — such as <a href="/basics/combine">Combine</a> in this case:</p><pre class="splash"><code><span class="s-preprocessing">#if canImport(Combine)</span>
<span class="s-keyword">import</span> Combine

<span class="s-keyword">public extension</span> <span class="s-type">GitHubSearchService</span> {
    <span class="s-keyword">func</span> publisherForRepisitories(
        matching query: <span class="s-type">String</span>
    ) -&gt; <span class="s-type">AnyPublisher</span>&lt;[<span class="s-type">Repository</span>], <span class="s-type">Error</span>&gt; {
        ...
    }
}
<span class="s-preprocessing">#endif</span></code></pre><p>The benefit of using <code>canImport</code> in situations like the above is that we don’t need to manually keep track of what platforms that a given framework is available on, and it also becomes crystal clear that the code within that block is defining a framework-specific API.</p><h2><a id="emitting-warnings-and-errors" href="#emitting-warnings-and-errors">Emitting warnings and errors</a></h2><p>The idea of intentionally producing warnings and errors within a code base might at first seem a bit strange, but can be an incredibly useful tool in many kinds of situations — for example if we want to remind ourselves of a shortcut that we just took, or if we want to add a bit of extra verification to our release builds.</p><p>For example, let’s say that we’re working on a deep linking system for a shopping app, and that in order to quickly get something up and running, we’ve made a few somewhat risky assumptions within the code used to extract a product ID from a given URL. So to give ourselves a very prominent reminder to go back and fix that code before submitting it, we could use the <code>#warning</code> directive, which will cause a warning to be emitted every time that our app is being compiled:</p><pre class="splash"><code><span class="s-keyword">func</span> extractProductID(from url: <span class="s-type">URL</span>) -&gt; <span class="s-type">Product</span>.<span class="s-type">ID</span> {
    <span class="s-preprocessing">#warning</span>(<span class="s-string">"Needs validation. Also uses a hard-coded index."</span>)
    <span class="s-keyword">let</span> components = url.<span class="s-property">pathComponents</span>
    <span class="s-keyword">let</span> rawID = components[<span class="s-number">2</span>]
    <span class="s-keyword">return</span> <span class="s-type">Product</span>.<span class="s-type">ID</span>(rawID)
}</code></pre><p>Another option would be to use a classic <code>TODO</code>-style comment, perhaps in combination with a linter in order to turn such comments into warnings — but by using the above approach we’re guaranteed to always get a warning issued by the Swift compiler itself, which in turn decreases the chance that the above shortcut will be forgotten and that our code will accidentally be shipped as-is.</p><p>To further improve the prominence of the above type of warnings, we could also enable the <code>Treat Warnings as Errors</code> build setting for our app’s release configuration, which turns all warnings into actual build errors when we’re building our app for release — completely preventing us from shipping any unfinished code that’s been marked with a warning.</p><p>It’s also possible to tell the compiler to directly produce an error as well, by using the <code>#error</code> directive, for example in order to show exactly what data that needs to be manually filled in after generating a piece of boilerplate code using some form of template:</p><pre class="splash"><code><span class="s-preprocessing">#error</span>(<span class="s-string">"Enter your public API key here"</span>)
<span class="s-keyword">let</span> service = <span class="s-type">AmazingAPIClient</span>(apiKey: <span class="s-string">""</span>)
...</code></pre><p>We could also conditionally emit an error in order to make sure that none of our debug-specific compiler flags were accidentally enabled for release builds — like this:</p><pre class="splash"><code><span class="s-preprocessing">#if !DEBUG &amp;&amp; ENABLE_INTERNAL_TOOLS
#error</span>(<span class="s-string">"Internal tools must be disabled in RELEASE builds."</span>)
<span class="s-preprocessing">#endif</span></code></pre><p>Adding the above kinds of checks within our source code might seem a bit excessive, but especially if we’re often tweaking what flags that are enabled within what builds, it could be a good idea to add a bit of extra protection to prevent debugging code from being shipped within App Store builds.</p><a class="sponsor" href="https://try.instabug.com/swiftbysundell?utm_source=swiftbysundell&amp;utm_medium=nativeads&amp;utm_campaign=swiftbysundell-nativeads-q320-aug-10" rel="nofollow" target="_blank"><img class="main" src="/images/sponsors/instabug-image.png" alt="Instabug"><div><p class="prefix">This ad keeps all of Swift by Sundell free for everyone. If you can, please check this sponsor out, as that directly helps support this site:</p><img class="mobile" src="/images/sponsors/instabug-image.png" alt="Instabug"><p><strong><span class="name">Instabug</span>:</strong> Catch bugs as soon as they happen and see exactly why each crash occurred. With Instabug you’ll automatically receive device data, network logs, and reproduction steps with every bug and crash report. It only takes a line of code to integrate. Start your free trial now and get three free months, <strong>exclusively for Swift by Sundell readers</strong>.</p></div></a><h2><a id="conclusion" href="#conclusion">Conclusion</a></h2><p>While Swift’s compiler directives might currently be quite limited compared to what some other languages offer, they still enable us to perform a fair amount of custom compile-time checks, and to create various kinds of conditional branches within our code.</p><p>However, while each of the directives that we took a look at in this article are useful within certain kinds of situations, it’s also important not to over-use them, as each time that we introduce a conditionally compiled code block, we’re essentially adding a new variant of our app that needs to be constantly tested and maintained.</p><p>Got questions, comments or feedback? You’re always welcome to contact me either via <a href="https://twitter.com/johnsundell">Twitter</a> or <a href="/contact">email</a>.</p><p>Thanks for reading! 🚀</p></div><ul class="actions"><li class="share"><a href="https://twitter.com/intent/tweet?via=johnsundell&amp;text=%E2%80%9CUsing%20compiler%20directives%20in%20Swift%E2%80%9D&amp;url=https%3A//www.swiftbysundell.com/articles/using-compiler-directives-in-swift" rel="nofollow">Share this article on Twitter</a></li></ul><div class="related-content"><div class="float-container"><h2>More on similar topics</h2><a class="browse-all" href="/tags">Browse all content by tag</a></div><ul class="item-list grid compact"><li><a aria-label="Overriding self with a weak reference" href="/tips/overriding-self-with-a-weak-reference"><article class="tips"><span class="type">Tip</span><h1>Overriding self with a weak reference</h1></article></a></li><li><a aria-label="Omitting the return keyword" href="/tips/omitting-the-return-keyword"><article class="tips"><span class="type">Tip</span><h1>Omitting the return keyword</h1></article></a></li><li><a aria-label="Mixing enums with other Swift types" href="/articles/mixing-enums-with-other-swift-types"><article class="article"><span class="type">Article</span><h1>Mixing enums with other Swift types</h1></article></a></li></ul></div></article>
<h1>Using compiler directives in Swift</h1>
<div class="metadata"><ul class="tags"><li class="variant-a"><a href="/tags/compiler">compiler</a></li><li class="variant-c"><a href="/tags/language-features">language features</a></li><li class="swift-version">Swift 5.2</li></ul><span class="date">Published on 16 Aug 2020</span></div>
<div class="content"><p>Even though Swift has a very strong compile-time focus when it comes to how it verifies and type-checks the code that we write, it’s still primarily used to implement runtime logic.</p><p>However, sometimes we might want to perform certain checks and run other kinds of custom logic when our code is being compiled, and although Swift doesn’t (yet) include a fully-featured macro or preprocessing system, it does ship with a few built-in compiler directives and conditions that enable us to influence the compilation process in various ways.</p><p>This week, let’s take a look at a few of those compiler directives and what sort of situations that each of them might be particularly useful in.</p><a class="sponsor" href="https://try.instabug.com/swiftbysundell?utm_source=swiftbysundell&amp;utm_medium=nativeads&amp;utm_campaign=swiftbysundell-nativeads-q320-aug-10" rel="nofollow" target="_blank"><img class="main" src="/images/sponsors/instabug-image.png" alt="Instabug"><div><p class="prefix">This ad keeps all of Swift by Sundell free for everyone. If you can, please check this sponsor out, as that directly helps support this site:</p><img class="mobile" src="/images/sponsors/instabug-image.png" alt="Instabug"><p><strong><span class="name">Instabug</span>:</strong> Catch bugs as soon as they happen and see exactly why each crash occurred. With Instabug you’ll automatically receive device data, network logs, and reproduction steps with every bug and crash report. It only takes a line of code to integrate. Start your free trial now and get three free months, <strong>exclusively for Swift by Sundell readers</strong>.</p></div></a><h2><a id="flags-and-environment-checks" href="#flags-and-environment-checks">Flags and environment checks</a></h2><p>Perhaps the most commonly used Swift compiler directive is the <code>#if</code> command, which enables us to conditionally include or exclude certain code blocks when our program is being compiled.</p><p>For example, we might use that command to check if our app is currently being compiled with its <em>debug</em> build configuration, by checking if the default <code>DEBUG</code> flag is enabled. Here we’re doing just that to conditionally print a given expression only within debug builds:</p><pre class="splash"><code><span class="s-keyword">func</span> log(<span class="s-keyword">_</span> expression: <span class="s-keyword">@autoclosure</span> () -&gt; <span class="s-type">Any</span>) {
    <span class="s-preprocessing">#if DEBUG</span>
    <span class="s-call">print</span>(<span class="s-call">expression</span>())
    <span class="s-preprocessing">#endif</span>
}</code></pre><p class="info">The <code>@autoclosure</code> attribute is used above to automatically turn any expression that was passed into our <code>log</code> function into a closure, in order to avoid evaluating it within release builds. To learn more about that attribute, check out <a href="/articles/using-autoclosure-when-designing-swift-apis">“Using @autoclosure when designing Swift APIs”</a>.</p><p>While the <code>DEBUG</code> flag provides an incredibly useful way to completely remove any code that we don’t want to include in our app’s shipping binary, sometimes we might want to use slightly more granular rules when deciding what code to include or remove.</p><p>That’s when <em>custom compilation conditions</em> can come in handy, which let us define our own, completely custom flags, which can then be enabled or disabled for different targets or build configurations. For example, let’s say that we’re currently working on a new SwiftUI-based profile view for an app, and while we’re not quite ready to ship that new implementation to the App Store, we do want to include it in internal builds of our app (such as TestFlight builds).</p><p>To make that happen, let’s define a dedicated <code>SWIFTUI_PROFILE</code> compiler condition, which we’ll only enable whenever we want to use our new SwiftUI-based profile view, and for all other builds, we’ll fall back to our previous UIKit-based implementation — like this:</p><pre class="splash"><code><span class="s-keyword">func</span> makeProfileViewController() -&gt; <span class="s-type">UIViewController</span> {
    <span class="s-preprocessing">#if SWIFTUI_PROFILE</span>
    <span class="s-keyword">return</span> <span class="s-type">UIHostingController</span>(rootView: <span class="s-type">ProfileView</span>())
    <span class="s-preprocessing">#else</span>
    <span class="s-keyword">return</span> <span class="s-type">ProfileViewController</span>()
    <span class="s-preprocessing">#endif</span>
}</code></pre><p>To toggle the above flag on or off, we can then either use the <code>Active Compilation Conditions</code> build setting in Xcode, or if we’re building a Swift Package Manager-based project, then we can enable it by passing <code>-Xswiftc SWIFTUI_PROFILE</code> to command line tools like <code>swift build</code>.</p><p class="info">To learn more about using feature flags, both compile-time and runtime ones, check out <a href="/articles/feature-flags-in-swift">“Feature flags in Swift”</a>.</p><p>Besides using various kinds of flags, another type of compilation condition that can be really useful is <code>targetEnvironment</code> — which lets us conditionally include a piece of code only when our app is being compiled for a given environment, such as <code>macCatalyst</code>, or the simulator. Here we’re using that feature to include a <code>DebugViewController</code> within an app’s tab bar when it’s being built for the iOS simulator:</p><pre class="splash"><code><span class="s-keyword">func</span> setupTabBarController(<span class="s-keyword">_</span> controller: <span class="s-type">UITabBarController</span>) {
    <span class="s-keyword">var</span> viewControllers = [<span class="s-type">UIViewController</span>]()

    <span class="s-preprocessing">#if targetEnvironment(simulator)</span>
    viewControllers.<span class="s-call">append</span>(<span class="s-type">DebugViewController</span>())
    <span class="s-preprocessing">#endif</span>

    controller.<span class="s-property">viewControllers</span> = viewControllers
}</code></pre><p>As the above code samples show, using compiler flags and the <code>targetEnvironment</code> condition is particularly useful when we want to strip out code that’s either debug-specific, or not quite ready to ship, while still enabling us to include that code within our main code base.</p><h2><a id="handling-platform-variations-within-cross-platform-code" href="#handling-platform-variations-within-cross-platform-code">Handling platform variations within cross-platform code</a></h2><p>Another type of situation in which compiler directives and conditional compilation can come in handy is whenever we’re working on a code base that supports multiple platforms — such as a cross-platform Swift package, or an app that runs on multiple Apple platforms.</p><p>As an example, let’s say that we’re working on a SwiftUI-based drawing app for iOS, macOS and tvOS, and that we’re looking to share as much code as possible between those three platforms. While many aspects of SwiftUIs overall API are identical across all of Apple’s platforms, which is a big advantage in situations like this, there are still platform-specific variations that we might need to handle.</p><p>For example, on iOS and macOS, SwiftUI supports adding a <code>DragGesture</code> to a given view, while that API is completely unavailable on tvOS — meaning that the following code won’t compile when building our app for that platform:</p><pre class="splash"><code><span class="s-keyword">struct</span> EditorView: <span class="s-type">View</span> {
    ...

    <span class="s-keyword">var</span> body: <span class="s-keyword">some</span> <span class="s-type">View</span> {
        <span class="s-type">CanvasView</span>().<span class="s-call">gesture</span>(<span class="s-type">DragGesture</span>().<span class="s-call">onChanged</span> { state <span class="s-keyword">in</span>
            ...
        })
        ...
    }
}</code></pre><p>To fix that problem, we could use the <code>os</code> compiler condition, which — just like the conditions we used earlier — enables us to only include a given piece of code when our app is being built for a specific platform. That, combined with the <code>#if</code> and <code>#else</code> directives, essentially lets us set up platform-specific branches within our cross-platform code — like this:</p><pre class="splash"><code><span class="s-keyword">struct</span> EditorView: <span class="s-type">View</span> {
    ...

    <span class="s-keyword">var</span> body: <span class="s-keyword">some</span> <span class="s-type">View</span> {
        <span class="s-preprocessing">#if os(tvOS)</span>
        <span class="s-type">CanvasView</span>()
        <span class="s-preprocessing">#else</span>
        <span class="s-type">CanvasView</span>().<span class="s-call">gesture</span>(<span class="s-type">DragGesture</span>().<span class="s-call">onChanged</span> { state <span class="s-keyword">in</span>
            ...
        })
        <span class="s-preprocessing">#endif</span>
        ...
    }
}</code></pre><p>However, while the above approach does work, it’s arguably a bit messy, and can easily lead to code that’s hard to both read and maintain — given that we’re mixing cross-platform and platform-specific code all within a single <code>View</code> implementation.</p><p>So instead, let’s see if we can isolate the above compilation condition a bit better. One way to do that would be to move it behind a dedicated abstraction, for example by implementing a custom modifier method for it, which could look something like this:</p><pre class="splash"><code><span class="s-keyword">extension</span> <span class="s-type">View</span> {
    <span class="s-keyword">func</span> addingDragGestureIfSupported(
        withHandler handler: <span class="s-keyword">@escaping</span> (<span class="s-type">CGPoint</span>) -&gt; <span class="s-type">Void</span>
    ) -&gt; <span class="s-keyword">some</span> <span class="s-type">View</span> {
        <span class="s-preprocessing">#if os(tvOS)</span>
        <span class="s-keyword">return self</span>
        <span class="s-preprocessing">#else</span>
        <span class="s-keyword">return</span> <span class="s-call">gesture</span>(<span class="s-type">DragGesture</span>().<span class="s-call">onChanged</span> { state <span class="s-keyword">in</span>
            <span class="s-call">handler</span>(state.<span class="s-property">location</span>)
        })
        <span class="s-preprocessing">#endif</span>
    }
}</code></pre><p>Since the above method signature doesn’t rely on any platform-specific types, but rather just <code>CGPoint</code> (which is available on all of Apple’s platforms as part of CoreGraphics), we can now freely call it within our cross-platform <code>EditorView</code>, and it’ll simply have no effect when our app is running on tvOS:</p><pre class="splash"><code><span class="s-keyword">struct</span> EditorView: <span class="s-type">View</span> {
    ...

    <span class="s-keyword">var</span> body: <span class="s-keyword">some</span> <span class="s-type">View</span> {
        <span class="s-type">CanvasView</span>().<span class="s-call">addingDragGestureIfSupported</span> { location <span class="s-keyword">in</span>
            ...
        }
        ...
    }
}</code></pre><p>Another option which can be good to keep in mind when dealing with the above kind of situation is to instead create multiple platform-specific variants of the same type. In our case, that could mean defining two separate <code>EditorView</code> types, one for tvOS and one for the other platforms, which could then be placed in two separate files. We’d then include the tvOS-specific file only within our app’s tvOS target, and the other one in the rest of our targets.</p><p>However, sometimes it might be more appropriate to check for the existence of a given module, rather than which platform that our code is being compiled for. That can be done using the <code>canImport</code> condition, which is particularly useful when we wish to extend an otherwise cross-platform API with features that rely on a framework that’s not universally available — such as <a href="/basics/combine">Combine</a> in this case:</p><pre class="splash"><code><span class="s-preprocessing">#if canImport(Combine)</span>
<span class="s-keyword">import</span> Combine

<span class="s-keyword">public extension</span> <span class="s-type">GitHubSearchService</span> {
    <span class="s-keyword">func</span> publisherForRepisitories(
        matching query: <span class="s-type">String</span>
    ) -&gt; <span class="s-type">AnyPublisher</span>&lt;[<span class="s-type">Repository</span>], <span class="s-type">Error</span>&gt; {
        ...
    }
}
<span class="s-preprocessing">#endif</span></code></pre><p>The benefit of using <code>canImport</code> in situations like the above is that we don’t need to manually keep track of what platforms that a given framework is available on, and it also becomes crystal clear that the code within that block is defining a framework-specific API.</p><h2><a id="emitting-warnings-and-errors" href="#emitting-warnings-and-errors">Emitting warnings and errors</a></h2><p>The idea of intentionally producing warnings and errors within a code base might at first seem a bit strange, but can be an incredibly useful tool in many kinds of situations — for example if we want to remind ourselves of a shortcut that we just took, or if we want to add a bit of extra verification to our release builds.</p><p>For example, let’s say that we’re working on a deep linking system for a shopping app, and that in order to quickly get something up and running, we’ve made a few somewhat risky assumptions within the code used to extract a product ID from a given URL. So to give ourselves a very prominent reminder to go back and fix that code before submitting it, we could use the <code>#warning</code> directive, which will cause a warning to be emitted every time that our app is being compiled:</p><pre class="splash"><code><span class="s-keyword">func</span> extractProductID(from url: <span class="s-type">URL</span>) -&gt; <span class="s-type">Product</span>.<span class="s-type">ID</span> {
    <span class="s-preprocessing">#warning</span>(<span class="s-string">"Needs validation. Also uses a hard-coded index."</span>)
    <span class="s-keyword">let</span> components = url.<span class="s-property">pathComponents</span>
    <span class="s-keyword">let</span> rawID = components[<span class="s-number">2</span>]
    <span class="s-keyword">return</span> <span class="s-type">Product</span>.<span class="s-type">ID</span>(rawID)
}</code></pre><p>Another option would be to use a classic <code>TODO</code>-style comment, perhaps in combination with a linter in order to turn such comments into warnings — but by using the above approach we’re guaranteed to always get a warning issued by the Swift compiler itself, which in turn decreases the chance that the above shortcut will be forgotten and that our code will accidentally be shipped as-is.</p><p>To further improve the prominence of the above type of warnings, we could also enable the <code>Treat Warnings as Errors</code> build setting for our app’s release configuration, which turns all warnings into actual build errors when we’re building our app for release — completely preventing us from shipping any unfinished code that’s been marked with a warning.</p><p>It’s also possible to tell the compiler to directly produce an error as well, by using the <code>#error</code> directive, for example in order to show exactly what data that needs to be manually filled in after generating a piece of boilerplate code using some form of template:</p><pre class="splash"><code><span class="s-preprocessing">#error</span>(<span class="s-string">"Enter your public API key here"</span>)
<span class="s-keyword">let</span> service = <span class="s-type">AmazingAPIClient</span>(apiKey: <span class="s-string">""</span>)
...</code></pre><p>We could also conditionally emit an error in order to make sure that none of our debug-specific compiler flags were accidentally enabled for release builds — like this:</p><pre class="splash"><code><span class="s-preprocessing">#if !DEBUG &amp;&amp; ENABLE_INTERNAL_TOOLS
#error</span>(<span class="s-string">"Internal tools must be disabled in RELEASE builds."</span>)
<span class="s-preprocessing">#endif</span></code></pre><p>Adding the above kinds of checks within our source code might seem a bit excessive, but especially if we’re often tweaking what flags that are enabled within what builds, it could be a good idea to add a bit of extra protection to prevent debugging code from being shipped within App Store builds.</p><a class="sponsor" href="https://try.instabug.com/swiftbysundell?utm_source=swiftbysundell&amp;utm_medium=nativeads&amp;utm_campaign=swiftbysundell-nativeads-q320-aug-10" rel="nofollow" target="_blank"><img class="main" src="/images/sponsors/instabug-image.png" alt="Instabug"><div><p class="prefix">This ad keeps all of Swift by Sundell free for everyone. If you can, please check this sponsor out, as that directly helps support this site:</p><img class="mobile" src="/images/sponsors/instabug-image.png" alt="Instabug"><p><strong><span class="name">Instabug</span>:</strong> Catch bugs as soon as they happen and see exactly why each crash occurred. With Instabug you’ll automatically receive device data, network logs, and reproduction steps with every bug and crash report. It only takes a line of code to integrate. Start your free trial now and get three free months, <strong>exclusively for Swift by Sundell readers</strong>.</p></div></a><h2><a id="conclusion" href="#conclusion">Conclusion</a></h2><p>While Swift’s compiler directives might currently be quite limited compared to what some other languages offer, they still enable us to perform a fair amount of custom compile-time checks, and to create various kinds of conditional branches within our code.</p><p>However, while each of the directives that we took a look at in this article are useful within certain kinds of situations, it’s also important not to over-use them, as each time that we introduce a conditionally compiled code block, we’re essentially adding a new variant of our app that needs to be constantly tested and maintained.</p><p>Got questions, comments or feedback? You’re always welcome to contact me either via <a href="https://twitter.com/johnsundell">Twitter</a> or <a href="/contact">email</a>.</p><p>Thanks for reading! 🚀</p></div>
<p>Even though Swift has a very strong compile-time focus when it comes to how it verifies and type-checks the code that we write, it’s still primarily used to implement runtime logic.</p>
<p>However, sometimes we might want to perform certain checks and run other kinds of custom logic when our code is being compiled, and although Swift doesn’t (yet) include a fully-featured macro or preprocessing system, it does ship with a few built-in compiler directives and conditions that enable us to influence the compilation process in various ways.</p>
<p>This week, let’s take a look at a few of those compiler directives and what sort of situations that each of them might be particularly useful in.</p>
<a class="sponsor" href="https://try.instabug.com/swiftbysundell?utm_source=swiftbysundell&amp;utm_medium=nativeads&amp;utm_campaign=swiftbysundell-nativeads-q320-aug-10" rel="nofollow" target="_blank"><img class="main" src="/images/sponsors/instabug-image.png" alt="Instabug"><div><p class="prefix">This ad keeps all of Swift by Sundell free for everyone. If you can, please check this sponsor out, as that directly helps support this site:</p><img class="mobile" src="/images/sponsors/instabug-image.png" alt="Instabug"><p><strong><span class="name">Instabug</span>:</strong> Catch bugs as soon as they happen and see exactly why each crash occurred. With Instabug you’ll automatically receive device data, network logs, and reproduction steps with every bug and crash report. It only takes a line of code to integrate. Start your free trial now and get three free months, <strong>exclusively for Swift by Sundell readers</strong>.</p></div></a>
<h2><a id="flags-and-environment-checks" href="#flags-and-environment-checks">Flags and environment checks</a></h2>
<p>Perhaps the most commonly used Swift compiler directive is the <code>#if</code> command, which enables us to conditionally include or exclude certain code blocks when our program is being compiled.</p>
<p>For example, we might use that command to check if our app is currently being compiled with its <em>debug</em> build configuration, by checking if the default <code>DEBUG</code> flag is enabled. Here we’re doing just that to conditionally print a given expression only within debug builds:</p>
<pre class="splash"><code><span class="s-keyword">func</span> log(<span class="s-keyword">_</span> expression: <span class="s-keyword">@autoclosure</span> () -&gt; <span class="s-type">Any</span>) {
    <span class="s-preprocessing">#if DEBUG</span>
    <span class="s-call">print</span>(<span class="s-call">expression</span>())
    <span class="s-preprocessing">#endif</span>
}</code></pre>
<p class="info">The <code>@autoclosure</code> attribute is used above to automatically turn any expression that was passed into our <code>log</code> function into a closure, in order to avoid evaluating it within release builds. To learn more about that attribute, check out <a href="/articles/using-autoclosure-when-designing-swift-apis">“Using @autoclosure when designing Swift APIs”</a>.</p>
<p>While the <code>DEBUG</code> flag provides an incredibly useful way to completely remove any code that we don’t want to include in our app’s shipping binary, sometimes we might want to use slightly more granular rules when deciding what code to include or remove.</p>
<p>That’s when <em>custom compilation conditions</em> can come in handy, which let us define our own, completely custom flags, which can then be enabled or disabled for different targets or build configurations. For example, let’s say that we’re currently working on a new SwiftUI-based profile view for an app, and while we’re not quite ready to ship that new implementation to the App Store, we do want to include it in internal builds of our app (such as TestFlight builds).</p>
<p>To make that happen, let’s define a dedicated <code>SWIFTUI_PROFILE</code> compiler condition, which we’ll only enable whenever we want to use our new SwiftUI-based profile view, and for all other builds, we’ll fall back to our previous UIKit-based implementation — like this:</p>
<pre class="splash"><code><span class="s-keyword">func</span> makeProfileViewController() -&gt; <span class="s-type">UIViewController</span> {
    <span class="s-preprocessing">#if SWIFTUI_PROFILE</span>
    <span class="s-keyword">return</span> <span class="s-type">UIHostingController</span>(rootView: <span class="s-type">ProfileView</span>())
    <span class="s-preprocessing">#else</span>
    <span class="s-keyword">return</span> <span class="s-type">ProfileViewController</span>()
    <span class="s-preprocessing">#endif</span>
}</code></pre>
<p>To toggle the above flag on or off, we can then either use the <code>Active Compilation Conditions</code> build setting in Xcode, or if we’re building a Swift Package Manager-based project, then we can enable it by passing <code>-Xswiftc SWIFTUI_PROFILE</code> to command line tools like <code>swift build</code>.</p>
<p class="info">To learn more about using feature flags, both compile-time and runtime ones, check out <a href="/articles/feature-flags-in-swift">“Feature flags in Swift”</a>.</p>
<p>Besides using various kinds of flags, another type of compilation condition that can be really useful is <code>targetEnvironment</code> — which lets us conditionally include a piece of code only when our app is being compiled for a given environment, such as <code>macCatalyst</code>, or the simulator. Here we’re using that feature to include a <code>DebugViewController</code> within an app’s tab bar when it’s being built for the iOS simulator:</p>
<pre class="splash"><code><span class="s-keyword">func</span> setupTabBarController(<span class="s-keyword">_</span> controller: <span class="s-type">UITabBarController</span>) {
    <span class="s-keyword">var</span> viewControllers = [<span class="s-type">UIViewController</span>]()

    <span class="s-preprocessing">#if targetEnvironment(simulator)</span>
    viewControllers.<span class="s-call">append</span>(<span class="s-type">DebugViewController</span>())
    <span class="s-preprocessing">#endif</span>

    controller.<span class="s-property">viewControllers</span> = viewControllers
}</code></pre>
<p>As the above code samples show, using compiler flags and the <code>targetEnvironment</code> condition is particularly useful when we want to strip out code that’s either debug-specific, or not quite ready to ship, while still enabling us to include that code within our main code base.</p>
<h2><a id="handling-platform-variations-within-cross-platform-code" href="#handling-platform-variations-within-cross-platform-code">Handling platform variations within cross-platform code</a></h2>
<p>Another type of situation in which compiler directives and conditional compilation can come in handy is whenever we’re working on a code base that supports multiple platforms — such as a cross-platform Swift package, or an app that runs on multiple Apple platforms.</p>
<p>As an example, let’s say that we’re working on a SwiftUI-based drawing app for iOS, macOS and tvOS, and that we’re looking to share as much code as possible between those three platforms. While many aspects of SwiftUIs overall API are identical across all of Apple’s platforms, which is a big advantage in situations like this, there are still platform-specific variations that we might need to handle.</p>
<p>For example, on iOS and macOS, SwiftUI supports adding a <code>DragGesture</code> to a given view, while that API is completely unavailable on tvOS — meaning that the following code won’t compile when building our app for that platform:</p>
<pre class="splash"><code><span class="s-keyword">struct</span> EditorView: <span class="s-type">View</span> {
    ...

    <span class="s-keyword">var</span> body: <span class="s-keyword">some</span> <span class="s-type">View</span> {
        <span class="s-type">CanvasView</span>().<span class="s-call">gesture</span>(<span class="s-type">DragGesture</span>().<span class="s-call">onChanged</span> { state <span class="s-keyword">in</span>
            ...
        })
        ...
    }
}</code></pre>
<p>To fix that problem, we could use the <code>os</code> compiler condition, which — just like the conditions we used earlier — enables us to only include a given piece of code when our app is being built for a specific platform. That, combined with the <code>#if</code> and <code>#else</code> directives, essentially lets us set up platform-specific branches within our cross-platform code — like this:</p>
<pre class="splash"><code><span class="s-keyword">struct</span> EditorView: <span class="s-type">View</span> {
    ...

    <span class="s-keyword">var</span> body: <span class="s-keyword">some</span> <span class="s-type">View</span> {
        <span class="s-preprocessing">#if os(tvOS)</span>
        <span class="s-type">CanvasView</span>()
        <span class="s-preprocessing">#else</span>
        <span class="s-type">CanvasView</span>().<span class="s-call">gesture</span>(<span class="s-type">DragGesture</span>().<span class="s-call">onChanged</span> { state <span class="s-keyword">in</span>
            ...
        })
        <span class="s-preprocessing">#endif</span>
        ...
    }
}</code></pre>
<p>However, while the above approach does work, it’s arguably a bit messy, and can easily lead to code that’s hard to both read and maintain — given that we’re mixing cross-platform and platform-specific code all within a single <code>View</code> implementation.</p>
<p>So instead, let’s see if we can isolate the above compilation condition a bit better. One way to do that would be to move it behind a dedicated abstraction, for example by implementing a custom modifier method for it, which could look something like this:</p>
<pre class="splash"><code><span class="s-keyword">extension</span> <span class="s-type">View</span> {
    <span class="s-keyword">func</span> addingDragGestureIfSupported(
        withHandler handler: <span class="s-keyword">@escaping</span> (<span class="s-type">CGPoint</span>) -&gt; <span class="s-type">Void</span>
    ) -&gt; <span class="s-keyword">some</span> <span class="s-type">View</span> {
        <span class="s-preprocessing">#if os(tvOS)</span>
        <span class="s-keyword">return self</span>
        <span class="s-preprocessing">#else</span>
        <span class="s-keyword">return</span> <span class="s-call">gesture</span>(<span class="s-type">DragGesture</span>().<span class="s-call">onChanged</span> { state <span class="s-keyword">in</span>
            <span class="s-call">handler</span>(state.<span class="s-property">location</span>)
        })
        <span class="s-preprocessing">#endif</span>
    }
}</code></pre>
<p>Since the above method signature doesn’t rely on any platform-specific types, but rather just <code>CGPoint</code> (which is available on all of Apple’s platforms as part of CoreGraphics), we can now freely call it within our cross-platform <code>EditorView</code>, and it’ll simply have no effect when our app is running on tvOS:</p>
<pre class="splash"><code><span class="s-keyword">struct</span> EditorView: <span class="s-type">View</span> {
    ...

    <span class="s-keyword">var</span> body: <span class="s-keyword">some</span> <span class="s-type">View</span> {
        <span class="s-type">CanvasView</span>().<span class="s-call">addingDragGestureIfSupported</span> { location <span class="s-keyword">in</span>
            ...
        }
        ...
    }
}</code></pre>
<p>Another option which can be good to keep in mind when dealing with the above kind of situation is to instead create multiple platform-specific variants of the same type. In our case, that could mean defining two separate <code>EditorView</code> types, one for tvOS and one for the other platforms, which could then be placed in two separate files. We’d then include the tvOS-specific file only within our app’s tvOS target, and the other one in the rest of our targets.</p>
<p>However, sometimes it might be more appropriate to check for the existence of a given module, rather than which platform that our code is being compiled for. That can be done using the <code>canImport</code> condition, which is particularly useful when we wish to extend an otherwise cross-platform API with features that rely on a framework that’s not universally available — such as <a href="/basics/combine">Combine</a> in this case:</p>
<pre class="splash"><code><span class="s-preprocessing">#if canImport(Combine)</span>
<span class="s-keyword">import</span> Combine

<span class="s-keyword">public extension</span> <span class="s-type">GitHubSearchService</span> {
    <span class="s-keyword">func</span> publisherForRepisitories(
        matching query: <span class="s-type">String</span>
    ) -&gt; <span class="s-type">AnyPublisher</span>&lt;[<span class="s-type">Repository</span>], <span class="s-type">Error</span>&gt; {
        ...
    }
}
<span class="s-preprocessing">#endif</span></code></pre>
<p>The benefit of using <code>canImport</code> in situations like the above is that we don’t need to manually keep track of what platforms that a given framework is available on, and it also becomes crystal clear that the code within that block is defining a framework-specific API.</p>
<h2><a id="emitting-warnings-and-errors" href="#emitting-warnings-and-errors">Emitting warnings and errors</a></h2>
<p>The idea of intentionally producing warnings and errors within a code base might at first seem a bit strange, but can be an incredibly useful tool in many kinds of situations — for example if we want to remind ourselves of a shortcut that we just took, or if we want to add a bit of extra verification to our release builds.</p>
<p>For example, let’s say that we’re working on a deep linking system for a shopping app, and that in order to quickly get something up and running, we’ve made a few somewhat risky assumptions within the code used to extract a product ID from a given URL. So to give ourselves a very prominent reminder to go back and fix that code before submitting it, we could use the <code>#warning</code> directive, which will cause a warning to be emitted every time that our app is being compiled:</p>
<pre class="splash"><code><span class="s-keyword">func</span> extractProductID(from url: <span class="s-type">URL</span>) -&gt; <span class="s-type">Product</span>.<span class="s-type">ID</span> {
    <span class="s-preprocessing">#warning</span>(<span class="s-string">"Needs validation. Also uses a hard-coded index."</span>)
    <span class="s-keyword">let</span> components = url.<span class="s-property">pathComponents</span>
    <span class="s-keyword">let</span> rawID = components[<span class="s-number">2</span>]
    <span class="s-keyword">return</span> <span class="s-type">Product</span>.<span class="s-type">ID</span>(rawID)
}</code></pre>
<p>Another option would be to use a classic <code>TODO</code>-style comment, perhaps in combination with a linter in order to turn such comments into warnings — but by using the above approach we’re guaranteed to always get a warning issued by the Swift compiler itself, which in turn decreases the chance that the above shortcut will be forgotten and that our code will accidentally be shipped as-is.</p>
<p>To further improve the prominence of the above type of warnings, we could also enable the <code>Treat Warnings as Errors</code> build setting for our app’s release configuration, which turns all warnings into actual build errors when we’re building our app for release — completely preventing us from shipping any unfinished code that’s been marked with a warning.</p>
<p>It’s also possible to tell the compiler to directly produce an error as well, by using the <code>#error</code> directive, for example in order to show exactly what data that needs to be manually filled in after generating a piece of boilerplate code using some form of template:</p>
<pre class="splash"><code><span class="s-preprocessing">#error</span>(<span class="s-string">"Enter your public API key here"</span>)
<span class="s-keyword">let</span> service = <span class="s-type">AmazingAPIClient</span>(apiKey: <span class="s-string">""</span>)
...</code></pre>
<code><span class="s-preprocessing">#error</span>(<span class="s-string">"Enter your public API key here"</span>)
<span class="s-keyword">let</span> service = <span class="s-type">AmazingAPIClient</span>(apiKey: <span class="s-string">""</span>)
...</code>
<span class="s-preprocessing">#error</span>
(
<span class="s-string">"Enter your public API key here"</span>
)

<span class="s-keyword">let</span>
 service =
<span class="s-type">AmazingAPIClient</span>
(apiKey:
<span class="s-string">""</span>
)
...
<code><span class="s-preprocessing">#error</span>(<span class="s-string">"Enter your public API key here"</span>)
<span class="s-keyword">let</span> service = <span class="s-type">AmazingAPIClient</span>(apiKey: <span class="s-string">""</span>)
...</code>
<pre class="splash"><code><span class="s-preprocessing">#error</span>(<span class="s-string">"Enter your public API key here"</span>)
<span class="s-keyword">let</span> service = <span class="s-type">AmazingAPIClient</span>(apiKey: <span class="s-string">""</span>)
...</code></pre>
<p>We could also conditionally emit an error in order to make sure that none of our debug-specific compiler flags were accidentally enabled for release builds — like this:</p>
<pre class="splash"><code><span class="s-preprocessing">#if !DEBUG &amp;&amp; ENABLE_INTERNAL_TOOLS
#error</span>(<span class="s-string">"Internal tools must be disabled in RELEASE builds."</span>)
<span class="s-preprocessing">#endif</span></code></pre>
<p>Adding the above kinds of checks within our source code might seem a bit excessive, but especially if we’re often tweaking what flags that are enabled within what builds, it could be a good idea to add a bit of extra protection to prevent debugging code from being shipped within App Store builds.</p>
<a class="sponsor" href="https://try.instabug.com/swiftbysundell?utm_source=swiftbysundell&amp;utm_medium=nativeads&amp;utm_campaign=swiftbysundell-nativeads-q320-aug-10" rel="nofollow" target="_blank"><img class="main" src="/images/sponsors/instabug-image.png" alt="Instabug"><div><p class="prefix">This ad keeps all of Swift by Sundell free for everyone. If you can, please check this sponsor out, as that directly helps support this site:</p><img class="mobile" src="/images/sponsors/instabug-image.png" alt="Instabug"><p><strong><span class="name">Instabug</span>:</strong> Catch bugs as soon as they happen and see exactly why each crash occurred. With Instabug you’ll automatically receive device data, network logs, and reproduction steps with every bug and crash report. It only takes a line of code to integrate. Start your free trial now and get three free months, <strong>exclusively for Swift by Sundell readers</strong>.</p></div></a>
<h2><a id="conclusion" href="#conclusion">Conclusion</a></h2>
<p>While Swift’s compiler directives might currently be quite limited compared to what some other languages offer, they still enable us to perform a fair amount of custom compile-time checks, and to create various kinds of conditional branches within our code.</p>
<p>However, while each of the directives that we took a look at in this article are useful within certain kinds of situations, it’s also important not to over-use them, as each time that we introduce a conditionally compiled code block, we’re essentially adding a new variant of our app that needs to be constantly tested and maintained.</p>
<p>Got questions, comments or feedback? You’re always welcome to contact me either via <a href="https://twitter.com/johnsundell">Twitter</a> or <a href="/contact">email</a>.</p>
<p>Thanks for reading! 🚀</p>
<div class="content"><p>Even though Swift has a very strong compile-time focus when it comes to how it verifies and type-checks the code that we write, it’s still primarily used to implement runtime logic.</p><p>However, sometimes we might want to perform certain checks and run other kinds of custom logic when our code is being compiled, and although Swift doesn’t (yet) include a fully-featured macro or preprocessing system, it does ship with a few built-in compiler directives and conditions that enable us to influence the compilation process in various ways.</p><p>This week, let’s take a look at a few of those compiler directives and what sort of situations that each of them might be particularly useful in.</p><a class="sponsor" href="https://try.instabug.com/swiftbysundell?utm_source=swiftbysundell&amp;utm_medium=nativeads&amp;utm_campaign=swiftbysundell-nativeads-q320-aug-10" rel="nofollow" target="_blank"><img class="main" src="/images/sponsors/instabug-image.png" alt="Instabug"><div><p class="prefix">This ad keeps all of Swift by Sundell free for everyone. If you can, please check this sponsor out, as that directly helps support this site:</p><img class="mobile" src="/images/sponsors/instabug-image.png" alt="Instabug"><p><strong><span class="name">Instabug</span>:</strong> Catch bugs as soon as they happen and see exactly why each crash occurred. With Instabug you’ll automatically receive device data, network logs, and reproduction steps with every bug and crash report. It only takes a line of code to integrate. Start your free trial now and get three free months, <strong>exclusively for Swift by Sundell readers</strong>.</p></div></a><h2><a id="flags-and-environment-checks" href="#flags-and-environment-checks">Flags and environment checks</a></h2><p>Perhaps the most commonly used Swift compiler directive is the <code>#if</code> command, which enables us to conditionally include or exclude certain code blocks when our program is being compiled.</p><p>For example, we might use that command to check if our app is currently being compiled with its <em>debug</em> build configuration, by checking if the default <code>DEBUG</code> flag is enabled. Here we’re doing just that to conditionally print a given expression only within debug builds:</p><pre class="splash"><code><span class="s-keyword">func</span> log(<span class="s-keyword">_</span> expression: <span class="s-keyword">@autoclosure</span> () -&gt; <span class="s-type">Any</span>) {
    <span class="s-preprocessing">#if DEBUG</span>
    <span class="s-call">print</span>(<span class="s-call">expression</span>())
    <span class="s-preprocessing">#endif</span>
}</code></pre><p class="info">The <code>@autoclosure</code> attribute is used above to automatically turn any expression that was passed into our <code>log</code> function into a closure, in order to avoid evaluating it within release builds. To learn more about that attribute, check out <a href="/articles/using-autoclosure-when-designing-swift-apis">“Using @autoclosure when designing Swift APIs”</a>.</p><p>While the <code>DEBUG</code> flag provides an incredibly useful way to completely remove any code that we don’t want to include in our app’s shipping binary, sometimes we might want to use slightly more granular rules when deciding what code to include or remove.</p><p>That’s when <em>custom compilation conditions</em> can come in handy, which let us define our own, completely custom flags, which can then be enabled or disabled for different targets or build configurations. For example, let’s say that we’re currently working on a new SwiftUI-based profile view for an app, and while we’re not quite ready to ship that new implementation to the App Store, we do want to include it in internal builds of our app (such as TestFlight builds).</p><p>To make that happen, let’s define a dedicated <code>SWIFTUI_PROFILE</code> compiler condition, which we’ll only enable whenever we want to use our new SwiftUI-based profile view, and for all other builds, we’ll fall back to our previous UIKit-based implementation — like this:</p><pre class="splash"><code><span class="s-keyword">func</span> makeProfileViewController() -&gt; <span class="s-type">UIViewController</span> {
    <span class="s-preprocessing">#if SWIFTUI_PROFILE</span>
    <span class="s-keyword">return</span> <span class="s-type">UIHostingController</span>(rootView: <span class="s-type">ProfileView</span>())
    <span class="s-preprocessing">#else</span>
    <span class="s-keyword">return</span> <span class="s-type">ProfileViewController</span>()
    <span class="s-preprocessing">#endif</span>
}</code></pre><p>To toggle the above flag on or off, we can then either use the <code>Active Compilation Conditions</code> build setting in Xcode, or if we’re building a Swift Package Manager-based project, then we can enable it by passing <code>-Xswiftc SWIFTUI_PROFILE</code> to command line tools like <code>swift build</code>.</p><p class="info">To learn more about using feature flags, both compile-time and runtime ones, check out <a href="/articles/feature-flags-in-swift">“Feature flags in Swift”</a>.</p><p>Besides using various kinds of flags, another type of compilation condition that can be really useful is <code>targetEnvironment</code> — which lets us conditionally include a piece of code only when our app is being compiled for a given environment, such as <code>macCatalyst</code>, or the simulator. Here we’re using that feature to include a <code>DebugViewController</code> within an app’s tab bar when it’s being built for the iOS simulator:</p><pre class="splash"><code><span class="s-keyword">func</span> setupTabBarController(<span class="s-keyword">_</span> controller: <span class="s-type">UITabBarController</span>) {
    <span class="s-keyword">var</span> viewControllers = [<span class="s-type">UIViewController</span>]()

    <span class="s-preprocessing">#if targetEnvironment(simulator)</span>
    viewControllers.<span class="s-call">append</span>(<span class="s-type">DebugViewController</span>())
    <span class="s-preprocessing">#endif</span>

    controller.<span class="s-property">viewControllers</span> = viewControllers
}</code></pre><p>As the above code samples show, using compiler flags and the <code>targetEnvironment</code> condition is particularly useful when we want to strip out code that’s either debug-specific, or not quite ready to ship, while still enabling us to include that code within our main code base.</p><h2><a id="handling-platform-variations-within-cross-platform-code" href="#handling-platform-variations-within-cross-platform-code">Handling platform variations within cross-platform code</a></h2><p>Another type of situation in which compiler directives and conditional compilation can come in handy is whenever we’re working on a code base that supports multiple platforms — such as a cross-platform Swift package, or an app that runs on multiple Apple platforms.</p><p>As an example, let’s say that we’re working on a SwiftUI-based drawing app for iOS, macOS and tvOS, and that we’re looking to share as much code as possible between those three platforms. While many aspects of SwiftUIs overall API are identical across all of Apple’s platforms, which is a big advantage in situations like this, there are still platform-specific variations that we might need to handle.</p><p>For example, on iOS and macOS, SwiftUI supports adding a <code>DragGesture</code> to a given view, while that API is completely unavailable on tvOS — meaning that the following code won’t compile when building our app for that platform:</p><pre class="splash"><code><span class="s-keyword">struct</span> EditorView: <span class="s-type">View</span> {
    ...

    <span class="s-keyword">var</span> body: <span class="s-keyword">some</span> <span class="s-type">View</span> {
        <span class="s-type">CanvasView</span>().<span class="s-call">gesture</span>(<span class="s-type">DragGesture</span>().<span class="s-call">onChanged</span> { state <span class="s-keyword">in</span>
            ...
        })
        ...
    }
}</code></pre><p>To fix that problem, we could use the <code>os</code> compiler condition, which — just like the conditions we used earlier — enables us to only include a given piece of code when our app is being built for a specific platform. That, combined with the <code>#if</code> and <code>#else</code> directives, essentially lets us set up platform-specific branches within our cross-platform code — like this:</p><pre class="splash"><code><span class="s-keyword">struct</span> EditorView: <span class="s-type">View</span> {
    ...

    <span class="s-keyword">var</span> body: <span class="s-keyword">some</span> <span class="s-type">View</span> {
        <span class="s-preprocessing">#if os(tvOS)</span>
        <span class="s-type">CanvasView</span>()
        <span class="s-preprocessing">#else</span>
        <span class="s-type">CanvasView</span>().<span class="s-call">gesture</span>(<span class="s-type">DragGesture</span>().<span class="s-call">onChanged</span> { state <span class="s-keyword">in</span>
            ...
        })
        <span class="s-preprocessing">#endif</span>
        ...
    }
}</code></pre><p>However, while the above approach does work, it’s arguably a bit messy, and can easily lead to code that’s hard to both read and maintain — given that we’re mixing cross-platform and platform-specific code all within a single <code>View</code> implementation.</p><p>So instead, let’s see if we can isolate the above compilation condition a bit better. One way to do that would be to move it behind a dedicated abstraction, for example by implementing a custom modifier method for it, which could look something like this:</p><pre class="splash"><code><span class="s-keyword">extension</span> <span class="s-type">View</span> {
    <span class="s-keyword">func</span> addingDragGestureIfSupported(
        withHandler handler: <span class="s-keyword">@escaping</span> (<span class="s-type">CGPoint</span>) -&gt; <span class="s-type">Void</span>
    ) -&gt; <span class="s-keyword">some</span> <span class="s-type">View</span> {
        <span class="s-preprocessing">#if os(tvOS)</span>
        <span class="s-keyword">return self</span>
        <span class="s-preprocessing">#else</span>
        <span class="s-keyword">return</span> <span class="s-call">gesture</span>(<span class="s-type">DragGesture</span>().<span class="s-call">onChanged</span> { state <span class="s-keyword">in</span>
            <span class="s-call">handler</span>(state.<span class="s-property">location</span>)
        })
        <span class="s-preprocessing">#endif</span>
    }
}</code></pre><p>Since the above method signature doesn’t rely on any platform-specific types, but rather just <code>CGPoint</code> (which is available on all of Apple’s platforms as part of CoreGraphics), we can now freely call it within our cross-platform <code>EditorView</code>, and it’ll simply have no effect when our app is running on tvOS:</p><pre class="splash"><code><span class="s-keyword">struct</span> EditorView: <span class="s-type">View</span> {
    ...

    <span class="s-keyword">var</span> body: <span class="s-keyword">some</span> <span class="s-type">View</span> {
        <span class="s-type">CanvasView</span>().<span class="s-call">addingDragGestureIfSupported</span> { location <span class="s-keyword">in</span>
            ...
        }
        ...
    }
}</code></pre><p>Another option which can be good to keep in mind when dealing with the above kind of situation is to instead create multiple platform-specific variants of the same type. In our case, that could mean defining two separate <code>EditorView</code> types, one for tvOS and one for the other platforms, which could then be placed in two separate files. We’d then include the tvOS-specific file only within our app’s tvOS target, and the other one in the rest of our targets.</p><p>However, sometimes it might be more appropriate to check for the existence of a given module, rather than which platform that our code is being compiled for. That can be done using the <code>canImport</code> condition, which is particularly useful when we wish to extend an otherwise cross-platform API with features that rely on a framework that’s not universally available — such as <a href="/basics/combine">Combine</a> in this case:</p><pre class="splash"><code><span class="s-preprocessing">#if canImport(Combine)</span>
<span class="s-keyword">import</span> Combine

<span class="s-keyword">public extension</span> <span class="s-type">GitHubSearchService</span> {
    <span class="s-keyword">func</span> publisherForRepisitories(
        matching query: <span class="s-type">String</span>
    ) -&gt; <span class="s-type">AnyPublisher</span>&lt;[<span class="s-type">Repository</span>], <span class="s-type">Error</span>&gt; {
        ...
    }
}
<span class="s-preprocessing">#endif</span></code></pre><p>The benefit of using <code>canImport</code> in situations like the above is that we don’t need to manually keep track of what platforms that a given framework is available on, and it also becomes crystal clear that the code within that block is defining a framework-specific API.</p><h2><a id="emitting-warnings-and-errors" href="#emitting-warnings-and-errors">Emitting warnings and errors</a></h2><p>The idea of intentionally producing warnings and errors within a code base might at first seem a bit strange, but can be an incredibly useful tool in many kinds of situations — for example if we want to remind ourselves of a shortcut that we just took, or if we want to add a bit of extra verification to our release builds.</p><p>For example, let’s say that we’re working on a deep linking system for a shopping app, and that in order to quickly get something up and running, we’ve made a few somewhat risky assumptions within the code used to extract a product ID from a given URL. So to give ourselves a very prominent reminder to go back and fix that code before submitting it, we could use the <code>#warning</code> directive, which will cause a warning to be emitted every time that our app is being compiled:</p><pre class="splash"><code><span class="s-keyword">func</span> extractProductID(from url: <span class="s-type">URL</span>) -&gt; <span class="s-type">Product</span>.<span class="s-type">ID</span> {
    <span class="s-preprocessing">#warning</span>(<span class="s-string">"Needs validation. Also uses a hard-coded index."</span>)
    <span class="s-keyword">let</span> components = url.<span class="s-property">pathComponents</span>
    <span class="s-keyword">let</span> rawID = components[<span class="s-number">2</span>]
    <span class="s-keyword">return</span> <span class="s-type">Product</span>.<span class="s-type">ID</span>(rawID)
}</code></pre><p>Another option would be to use a classic <code>TODO</code>-style comment, perhaps in combination with a linter in order to turn such comments into warnings — but by using the above approach we’re guaranteed to always get a warning issued by the Swift compiler itself, which in turn decreases the chance that the above shortcut will be forgotten and that our code will accidentally be shipped as-is.</p><p>To further improve the prominence of the above type of warnings, we could also enable the <code>Treat Warnings as Errors</code> build setting for our app’s release configuration, which turns all warnings into actual build errors when we’re building our app for release — completely preventing us from shipping any unfinished code that’s been marked with a warning.</p><p>It’s also possible to tell the compiler to directly produce an error as well, by using the <code>#error</code> directive, for example in order to show exactly what data that needs to be manually filled in after generating a piece of boilerplate code using some form of template:</p><pre class="splash"><code><span class="s-preprocessing">#error</span>(<span class="s-string">"Enter your public API key here"</span>)
<span class="s-keyword">let</span> service = <span class="s-type">AmazingAPIClient</span>(apiKey: <span class="s-string">""</span>)
...</code></pre><p>We could also conditionally emit an error in order to make sure that none of our debug-specific compiler flags were accidentally enabled for release builds — like this:</p><pre class="splash"><code><span class="s-preprocessing">#if !DEBUG &amp;&amp; ENABLE_INTERNAL_TOOLS
#error</span>(<span class="s-string">"Internal tools must be disabled in RELEASE builds."</span>)
<span class="s-preprocessing">#endif</span></code></pre><p>Adding the above kinds of checks within our source code might seem a bit excessive, but especially if we’re often tweaking what flags that are enabled within what builds, it could be a good idea to add a bit of extra protection to prevent debugging code from being shipped within App Store builds.</p><a class="sponsor" href="https://try.instabug.com/swiftbysundell?utm_source=swiftbysundell&amp;utm_medium=nativeads&amp;utm_campaign=swiftbysundell-nativeads-q320-aug-10" rel="nofollow" target="_blank"><img class="main" src="/images/sponsors/instabug-image.png" alt="Instabug"><div><p class="prefix">This ad keeps all of Swift by Sundell free for everyone. If you can, please check this sponsor out, as that directly helps support this site:</p><img class="mobile" src="/images/sponsors/instabug-image.png" alt="Instabug"><p><strong><span class="name">Instabug</span>:</strong> Catch bugs as soon as they happen and see exactly why each crash occurred. With Instabug you’ll automatically receive device data, network logs, and reproduction steps with every bug and crash report. It only takes a line of code to integrate. Start your free trial now and get three free months, <strong>exclusively for Swift by Sundell readers</strong>.</p></div></a><h2><a id="conclusion" href="#conclusion">Conclusion</a></h2><p>While Swift’s compiler directives might currently be quite limited compared to what some other languages offer, they still enable us to perform a fair amount of custom compile-time checks, and to create various kinds of conditional branches within our code.</p><p>However, while each of the directives that we took a look at in this article are useful within certain kinds of situations, it’s also important not to over-use them, as each time that we introduce a conditionally compiled code block, we’re essentially adding a new variant of our app that needs to be constantly tested and maintained.</p><p>Got questions, comments or feedback? You’re always welcome to contact me either via <a href="https://twitter.com/johnsundell">Twitter</a> or <a href="/contact">email</a>.</p><p>Thanks for reading! 🚀</p></div>
<ul class="actions"><li class="share"><a href="https://twitter.com/intent/tweet?via=johnsundell&amp;text=%E2%80%9CUsing%20compiler%20directives%20in%20Swift%E2%80%9D&amp;url=https%3A//www.swiftbysundell.com/articles/using-compiler-directives-in-swift" rel="nofollow">Share this article on Twitter</a></li></ul>
<div class="related-content"><div class="float-container"><h2>More on similar topics</h2><a class="browse-all" href="/tags">Browse all content by tag</a></div><ul class="item-list grid compact"><li><a aria-label="Overriding self with a weak reference" href="/tips/overriding-self-with-a-weak-reference"><article class="tips"><span class="type">Tip</span><h1>Overriding self with a weak reference</h1></article></a></li><li><a aria-label="Omitting the return keyword" href="/tips/omitting-the-return-keyword"><article class="tips"><span class="type">Tip</span><h1>Omitting the return keyword</h1></article></a></li><li><a aria-label="Mixing enums with other Swift types" href="/articles/mixing-enums-with-other-swift-types"><article class="article"><span class="type">Article</span><h1>Mixing enums with other Swift types</h1></article></a></li></ul></div>
<article class="page wrapper article"><h1>Using compiler directives in Swift</h1><div class="metadata"><ul class="tags"><li class="variant-a"><a href="/tags/compiler">compiler</a></li><li class="variant-c"><a href="/tags/language-features">language features</a></li><li class="swift-version">Swift 5.2</li></ul><span class="date">Published on 16 Aug 2020</span></div><div class="content"><p>Even though Swift has a very strong compile-time focus when it comes to how it verifies and type-checks the code that we write, it’s still primarily used to implement runtime logic.</p><p>However, sometimes we might want to perform certain checks and run other kinds of custom logic when our code is being compiled, and although Swift doesn’t (yet) include a fully-featured macro or preprocessing system, it does ship with a few built-in compiler directives and conditions that enable us to influence the compilation process in various ways.</p><p>This week, let’s take a look at a few of those compiler directives and what sort of situations that each of them might be particularly useful in.</p><a class="sponsor" href="https://try.instabug.com/swiftbysundell?utm_source=swiftbysundell&amp;utm_medium=nativeads&amp;utm_campaign=swiftbysundell-nativeads-q320-aug-10" rel="nofollow" target="_blank"><img class="main" src="/images/sponsors/instabug-image.png" alt="Instabug"><div><p class="prefix">This ad keeps all of Swift by Sundell free for everyone. If you can, please check this sponsor out, as that directly helps support this site:</p><img class="mobile" src="/images/sponsors/instabug-image.png" alt="Instabug"><p><strong><span class="name">Instabug</span>:</strong> Catch bugs as soon as they happen and see exactly why each crash occurred. With Instabug you’ll automatically receive device data, network logs, and reproduction steps with every bug and crash report. It only takes a line of code to integrate. Start your free trial now and get three free months, <strong>exclusively for Swift by Sundell readers</strong>.</p></div></a><h2><a id="flags-and-environment-checks" href="#flags-and-environment-checks">Flags and environment checks</a></h2><p>Perhaps the most commonly used Swift compiler directive is the <code>#if</code> command, which enables us to conditionally include or exclude certain code blocks when our program is being compiled.</p><p>For example, we might use that command to check if our app is currently being compiled with its <em>debug</em> build configuration, by checking if the default <code>DEBUG</code> flag is enabled. Here we’re doing just that to conditionally print a given expression only within debug builds:</p><pre class="splash"><code><span class="s-keyword">func</span> log(<span class="s-keyword">_</span> expression: <span class="s-keyword">@autoclosure</span> () -&gt; <span class="s-type">Any</span>) {
    <span class="s-preprocessing">#if DEBUG</span>
    <span class="s-call">print</span>(<span class="s-call">expression</span>())
    <span class="s-preprocessing">#endif</span>
}</code></pre><p class="info">The <code>@autoclosure</code> attribute is used above to automatically turn any expression that was passed into our <code>log</code> function into a closure, in order to avoid evaluating it within release builds. To learn more about that attribute, check out <a href="/articles/using-autoclosure-when-designing-swift-apis">“Using @autoclosure when designing Swift APIs”</a>.</p><p>While the <code>DEBUG</code> flag provides an incredibly useful way to completely remove any code that we don’t want to include in our app’s shipping binary, sometimes we might want to use slightly more granular rules when deciding what code to include or remove.</p><p>That’s when <em>custom compilation conditions</em> can come in handy, which let us define our own, completely custom flags, which can then be enabled or disabled for different targets or build configurations. For example, let’s say that we’re currently working on a new SwiftUI-based profile view for an app, and while we’re not quite ready to ship that new implementation to the App Store, we do want to include it in internal builds of our app (such as TestFlight builds).</p><p>To make that happen, let’s define a dedicated <code>SWIFTUI_PROFILE</code> compiler condition, which we’ll only enable whenever we want to use our new SwiftUI-based profile view, and for all other builds, we’ll fall back to our previous UIKit-based implementation — like this:</p><pre class="splash"><code><span class="s-keyword">func</span> makeProfileViewController() -&gt; <span class="s-type">UIViewController</span> {
    <span class="s-preprocessing">#if SWIFTUI_PROFILE</span>
    <span class="s-keyword">return</span> <span class="s-type">UIHostingController</span>(rootView: <span class="s-type">ProfileView</span>())
    <span class="s-preprocessing">#else</span>
    <span class="s-keyword">return</span> <span class="s-type">ProfileViewController</span>()
    <span class="s-preprocessing">#endif</span>
}</code></pre><p>To toggle the above flag on or off, we can then either use the <code>Active Compilation Conditions</code> build setting in Xcode, or if we’re building a Swift Package Manager-based project, then we can enable it by passing <code>-Xswiftc SWIFTUI_PROFILE</code> to command line tools like <code>swift build</code>.</p><p class="info">To learn more about using feature flags, both compile-time and runtime ones, check out <a href="/articles/feature-flags-in-swift">“Feature flags in Swift”</a>.</p><p>Besides using various kinds of flags, another type of compilation condition that can be really useful is <code>targetEnvironment</code> — which lets us conditionally include a piece of code only when our app is being compiled for a given environment, such as <code>macCatalyst</code>, or the simulator. Here we’re using that feature to include a <code>DebugViewController</code> within an app’s tab bar when it’s being built for the iOS simulator:</p><pre class="splash"><code><span class="s-keyword">func</span> setupTabBarController(<span class="s-keyword">_</span> controller: <span class="s-type">UITabBarController</span>) {
    <span class="s-keyword">var</span> viewControllers = [<span class="s-type">UIViewController</span>]()

    <span class="s-preprocessing">#if targetEnvironment(simulator)</span>
    viewControllers.<span class="s-call">append</span>(<span class="s-type">DebugViewController</span>())
    <span class="s-preprocessing">#endif</span>

    controller.<span class="s-property">viewControllers</span> = viewControllers
}</code></pre><p>As the above code samples show, using compiler flags and the <code>targetEnvironment</code> condition is particularly useful when we want to strip out code that’s either debug-specific, or not quite ready to ship, while still enabling us to include that code within our main code base.</p><h2><a id="handling-platform-variations-within-cross-platform-code" href="#handling-platform-variations-within-cross-platform-code">Handling platform variations within cross-platform code</a></h2><p>Another type of situation in which compiler directives and conditional compilation can come in handy is whenever we’re working on a code base that supports multiple platforms — such as a cross-platform Swift package, or an app that runs on multiple Apple platforms.</p><p>As an example, let’s say that we’re working on a SwiftUI-based drawing app for iOS, macOS and tvOS, and that we’re looking to share as much code as possible between those three platforms. While many aspects of SwiftUIs overall API are identical across all of Apple’s platforms, which is a big advantage in situations like this, there are still platform-specific variations that we might need to handle.</p><p>For example, on iOS and macOS, SwiftUI supports adding a <code>DragGesture</code> to a given view, while that API is completely unavailable on tvOS — meaning that the following code won’t compile when building our app for that platform:</p><pre class="splash"><code><span class="s-keyword">struct</span> EditorView: <span class="s-type">View</span> {
    ...

    <span class="s-keyword">var</span> body: <span class="s-keyword">some</span> <span class="s-type">View</span> {
        <span class="s-type">CanvasView</span>().<span class="s-call">gesture</span>(<span class="s-type">DragGesture</span>().<span class="s-call">onChanged</span> { state <span class="s-keyword">in</span>
            ...
        })
        ...
    }
}</code></pre><p>To fix that problem, we could use the <code>os</code> compiler condition, which — just like the conditions we used earlier — enables us to only include a given piece of code when our app is being built for a specific platform. That, combined with the <code>#if</code> and <code>#else</code> directives, essentially lets us set up platform-specific branches within our cross-platform code — like this:</p><pre class="splash"><code><span class="s-keyword">struct</span> EditorView: <span class="s-type">View</span> {
    ...

    <span class="s-keyword">var</span> body: <span class="s-keyword">some</span> <span class="s-type">View</span> {
        <span class="s-preprocessing">#if os(tvOS)</span>
        <span class="s-type">CanvasView</span>()
        <span class="s-preprocessing">#else</span>
        <span class="s-type">CanvasView</span>().<span class="s-call">gesture</span>(<span class="s-type">DragGesture</span>().<span class="s-call">onChanged</span> { state <span class="s-keyword">in</span>
            ...
        })
        <span class="s-preprocessing">#endif</span>
        ...
    }
}</code></pre><p>However, while the above approach does work, it’s arguably a bit messy, and can easily lead to code that’s hard to both read and maintain — given that we’re mixing cross-platform and platform-specific code all within a single <code>View</code> implementation.</p><p>So instead, let’s see if we can isolate the above compilation condition a bit better. One way to do that would be to move it behind a dedicated abstraction, for example by implementing a custom modifier method for it, which could look something like this:</p><pre class="splash"><code><span class="s-keyword">extension</span> <span class="s-type">View</span> {
    <span class="s-keyword">func</span> addingDragGestureIfSupported(
        withHandler handler: <span class="s-keyword">@escaping</span> (<span class="s-type">CGPoint</span>) -&gt; <span class="s-type">Void</span>
    ) -&gt; <span class="s-keyword">some</span> <span class="s-type">View</span> {
        <span class="s-preprocessing">#if os(tvOS)</span>
        <span class="s-keyword">return self</span>
        <span class="s-preprocessing">#else</span>
        <span class="s-keyword">return</span> <span class="s-call">gesture</span>(<span class="s-type">DragGesture</span>().<span class="s-call">onChanged</span> { state <span class="s-keyword">in</span>
            <span class="s-call">handler</span>(state.<span class="s-property">location</span>)
        })
        <span class="s-preprocessing">#endif</span>
    }
}</code></pre><p>Since the above method signature doesn’t rely on any platform-specific types, but rather just <code>CGPoint</code> (which is available on all of Apple’s platforms as part of CoreGraphics), we can now freely call it within our cross-platform <code>EditorView</code>, and it’ll simply have no effect when our app is running on tvOS:</p><pre class="splash"><code><span class="s-keyword">struct</span> EditorView: <span class="s-type">View</span> {
    ...

    <span class="s-keyword">var</span> body: <span class="s-keyword">some</span> <span class="s-type">View</span> {
        <span class="s-type">CanvasView</span>().<span class="s-call">addingDragGestureIfSupported</span> { location <span class="s-keyword">in</span>
            ...
        }
        ...
    }
}</code></pre><p>Another option which can be good to keep in mind when dealing with the above kind of situation is to instead create multiple platform-specific variants of the same type. In our case, that could mean defining two separate <code>EditorView</code> types, one for tvOS and one for the other platforms, which could then be placed in two separate files. We’d then include the tvOS-specific file only within our app’s tvOS target, and the other one in the rest of our targets.</p><p>However, sometimes it might be more appropriate to check for the existence of a given module, rather than which platform that our code is being compiled for. That can be done using the <code>canImport</code> condition, which is particularly useful when we wish to extend an otherwise cross-platform API with features that rely on a framework that’s not universally available — such as <a href="/basics/combine">Combine</a> in this case:</p><pre class="splash"><code><span class="s-preprocessing">#if canImport(Combine)</span>
<span class="s-keyword">import</span> Combine

<span class="s-keyword">public extension</span> <span class="s-type">GitHubSearchService</span> {
    <span class="s-keyword">func</span> publisherForRepisitories(
        matching query: <span class="s-type">String</span>
    ) -&gt; <span class="s-type">AnyPublisher</span>&lt;[<span class="s-type">Repository</span>], <span class="s-type">Error</span>&gt; {
        ...
    }
}
<span class="s-preprocessing">#endif</span></code></pre><p>The benefit of using <code>canImport</code> in situations like the above is that we don’t need to manually keep track of what platforms that a given framework is available on, and it also becomes crystal clear that the code within that block is defining a framework-specific API.</p><h2><a id="emitting-warnings-and-errors" href="#emitting-warnings-and-errors">Emitting warnings and errors</a></h2><p>The idea of intentionally producing warnings and errors within a code base might at first seem a bit strange, but can be an incredibly useful tool in many kinds of situations — for example if we want to remind ourselves of a shortcut that we just took, or if we want to add a bit of extra verification to our release builds.</p><p>For example, let’s say that we’re working on a deep linking system for a shopping app, and that in order to quickly get something up and running, we’ve made a few somewhat risky assumptions within the code used to extract a product ID from a given URL. So to give ourselves a very prominent reminder to go back and fix that code before submitting it, we could use the <code>#warning</code> directive, which will cause a warning to be emitted every time that our app is being compiled:</p><pre class="splash"><code><span class="s-keyword">func</span> extractProductID(from url: <span class="s-type">URL</span>) -&gt; <span class="s-type">Product</span>.<span class="s-type">ID</span> {
    <span class="s-preprocessing">#warning</span>(<span class="s-string">"Needs validation. Also uses a hard-coded index."</span>)
    <span class="s-keyword">let</span> components = url.<span class="s-property">pathComponents</span>
    <span class="s-keyword">let</span> rawID = components[<span class="s-number">2</span>]
    <span class="s-keyword">return</span> <span class="s-type">Product</span>.<span class="s-type">ID</span>(rawID)
}</code></pre><p>Another option would be to use a classic <code>TODO</code>-style comment, perhaps in combination with a linter in order to turn such comments into warnings — but by using the above approach we’re guaranteed to always get a warning issued by the Swift compiler itself, which in turn decreases the chance that the above shortcut will be forgotten and that our code will accidentally be shipped as-is.</p><p>To further improve the prominence of the above type of warnings, we could also enable the <code>Treat Warnings as Errors</code> build setting for our app’s release configuration, which turns all warnings into actual build errors when we’re building our app for release — completely preventing us from shipping any unfinished code that’s been marked with a warning.</p><p>It’s also possible to tell the compiler to directly produce an error as well, by using the <code>#error</code> directive, for example in order to show exactly what data that needs to be manually filled in after generating a piece of boilerplate code using some form of template:</p><pre class="splash"><code><span class="s-preprocessing">#error</span>(<span class="s-string">"Enter your public API key here"</span>)
<span class="s-keyword">let</span> service = <span class="s-type">AmazingAPIClient</span>(apiKey: <span class="s-string">""</span>)
...</code></pre><p>We could also conditionally emit an error in order to make sure that none of our debug-specific compiler flags were accidentally enabled for release builds — like this:</p><pre class="splash"><code><span class="s-preprocessing">#if !DEBUG &amp;&amp; ENABLE_INTERNAL_TOOLS
#error</span>(<span class="s-string">"Internal tools must be disabled in RELEASE builds."</span>)
<span class="s-preprocessing">#endif</span></code></pre><p>Adding the above kinds of checks within our source code might seem a bit excessive, but especially if we’re often tweaking what flags that are enabled within what builds, it could be a good idea to add a bit of extra protection to prevent debugging code from being shipped within App Store builds.</p><a class="sponsor" href="https://try.instabug.com/swiftbysundell?utm_source=swiftbysundell&amp;utm_medium=nativeads&amp;utm_campaign=swiftbysundell-nativeads-q320-aug-10" rel="nofollow" target="_blank"><img class="main" src="/images/sponsors/instabug-image.png" alt="Instabug"><div><p class="prefix">This ad keeps all of Swift by Sundell free for everyone. If you can, please check this sponsor out, as that directly helps support this site:</p><img class="mobile" src="/images/sponsors/instabug-image.png" alt="Instabug"><p><strong><span class="name">Instabug</span>:</strong> Catch bugs as soon as they happen and see exactly why each crash occurred. With Instabug you’ll automatically receive device data, network logs, and reproduction steps with every bug and crash report. It only takes a line of code to integrate. Start your free trial now and get three free months, <strong>exclusively for Swift by Sundell readers</strong>.</p></div></a><h2><a id="conclusion" href="#conclusion">Conclusion</a></h2><p>While Swift’s compiler directives might currently be quite limited compared to what some other languages offer, they still enable us to perform a fair amount of custom compile-time checks, and to create various kinds of conditional branches within our code.</p><p>However, while each of the directives that we took a look at in this article are useful within certain kinds of situations, it’s also important not to over-use them, as each time that we introduce a conditionally compiled code block, we’re essentially adding a new variant of our app that needs to be constantly tested and maintained.</p><p>Got questions, comments or feedback? You’re always welcome to contact me either via <a href="https://twitter.com/johnsundell">Twitter</a> or <a href="/contact">email</a>.</p><p>Thanks for reading! 🚀</p></div><ul class="actions"><li class="share"><a href="https://twitter.com/intent/tweet?via=johnsundell&amp;text=%E2%80%9CUsing%20compiler%20directives%20in%20Swift%E2%80%9D&amp;url=https%3A//www.swiftbysundell.com/articles/using-compiler-directives-in-swift" rel="nofollow">Share this article on Twitter</a></li></ul><div class="related-content"><div class="float-container"><h2>More on similar topics</h2><a class="browse-all" href="/tags">Browse all content by tag</a></div><ul class="item-list grid compact"><li><a aria-label="Overriding self with a weak reference" href="/tips/overriding-self-with-a-weak-reference"><article class="tips"><span class="type">Tip</span><h1>Overriding self with a weak reference</h1></article></a></li><li><a aria-label="Omitting the return keyword" href="/tips/omitting-the-return-keyword"><article class="tips"><span class="type">Tip</span><h1>Omitting the return keyword</h1></article></a></li><li><a aria-label="Mixing enums with other Swift types" href="/articles/mixing-enums-with-other-swift-types"><article class="article"><span class="type">Article</span><h1>Mixing enums with other Swift types</h1></article></a></li></ul></div></article>
<a aria-label="A deep dive into Swift’s function builders" class="pagination previous" href="/articles/deep-dive-into-swift-function-builders"><b>Previous:</b> A deep dive into Swift’s function builders</a>
<footer><p>Copyright © Sundell sp. z o.o. 2020.</p><p>Built in Swift using <a href="https://github.com/johnsundell/publish">Publish</a>.</p><p><a href="https://twitter.com/swiftbysundell" rel="nofollow" target="_blank">Twitter</a> | <a href="/subscribe">RSS</a> | <a href="/contact">Contact</a></p></footer>
<body class="item"><header><div class="wrapper"><a href="/"><img class="logo" src="/images/logo.png" alt="Swift by Sundell"></a><p>Weekly Swift articles, podcasts and tips by <span class="inline-block"><a href="https://twitter.com/johnsundell" rel="nofollow" target="_blank">John Sundell</a>.</span></p><nav><ul><li class="selected"><a href="/articles">Weekly articles</a></li><li><a href="/basics">Basics</a></li><li><a href="/podcast">Podcast</a></li><li><a href="/tips">Tips</a></li><li><a href="/videos">Videos</a></li><li><a href="/questions">Q&amp;A</a></li><li><a href="/sponsor">Sponsorship</a></li><li class="search"><a href="/search">Search</a></li></ul></nav></div></header><article class="page wrapper article"><h1>Using compiler directives in Swift</h1><div class="metadata"><ul class="tags"><li class="variant-a"><a href="/tags/compiler">compiler</a></li><li class="variant-c"><a href="/tags/language-features">language features</a></li><li class="swift-version">Swift 5.2</li></ul><span class="date">Published on 16 Aug 2020</span></div><div class="content"><p>Even though Swift has a very strong compile-time focus when it comes to how it verifies and type-checks the code that we write, it’s still primarily used to implement runtime logic.</p><p>However, sometimes we might want to perform certain checks and run other kinds of custom logic when our code is being compiled, and although Swift doesn’t (yet) include a fully-featured macro or preprocessing system, it does ship with a few built-in compiler directives and conditions that enable us to influence the compilation process in various ways.</p><p>This week, let’s take a look at a few of those compiler directives and what sort of situations that each of them might be particularly useful in.</p><a class="sponsor" href="https://try.instabug.com/swiftbysundell?utm_source=swiftbysundell&amp;utm_medium=nativeads&amp;utm_campaign=swiftbysundell-nativeads-q320-aug-10" rel="nofollow" target="_blank"><img class="main" src="/images/sponsors/instabug-image.png" alt="Instabug"><div><p class="prefix">This ad keeps all of Swift by Sundell free for everyone. If you can, please check this sponsor out, as that directly helps support this site:</p><img class="mobile" src="/images/sponsors/instabug-image.png" alt="Instabug"><p><strong><span class="name">Instabug</span>:</strong> Catch bugs as soon as they happen and see exactly why each crash occurred. With Instabug you’ll automatically receive device data, network logs, and reproduction steps with every bug and crash report. It only takes a line of code to integrate. Start your free trial now and get three free months, <strong>exclusively for Swift by Sundell readers</strong>.</p></div></a><h2><a id="flags-and-environment-checks" href="#flags-and-environment-checks">Flags and environment checks</a></h2><p>Perhaps the most commonly used Swift compiler directive is the <code>#if</code> command, which enables us to conditionally include or exclude certain code blocks when our program is being compiled.</p><p>For example, we might use that command to check if our app is currently being compiled with its <em>debug</em> build configuration, by checking if the default <code>DEBUG</code> flag is enabled. Here we’re doing just that to conditionally print a given expression only within debug builds:</p><pre class="splash"><code><span class="s-keyword">func</span> log(<span class="s-keyword">_</span> expression: <span class="s-keyword">@autoclosure</span> () -&gt; <span class="s-type">Any</span>) {
    <span class="s-preprocessing">#if DEBUG</span>
    <span class="s-call">print</span>(<span class="s-call">expression</span>())
    <span class="s-preprocessing">#endif</span>
}</code></pre><p class="info">The <code>@autoclosure</code> attribute is used above to automatically turn any expression that was passed into our <code>log</code> function into a closure, in order to avoid evaluating it within release builds. To learn more about that attribute, check out <a href="/articles/using-autoclosure-when-designing-swift-apis">“Using @autoclosure when designing Swift APIs”</a>.</p><p>While the <code>DEBUG</code> flag provides an incredibly useful way to completely remove any code that we don’t want to include in our app’s shipping binary, sometimes we might want to use slightly more granular rules when deciding what code to include or remove.</p><p>That’s when <em>custom compilation conditions</em> can come in handy, which let us define our own, completely custom flags, which can then be enabled or disabled for different targets or build configurations. For example, let’s say that we’re currently working on a new SwiftUI-based profile view for an app, and while we’re not quite ready to ship that new implementation to the App Store, we do want to include it in internal builds of our app (such as TestFlight builds).</p><p>To make that happen, let’s define a dedicated <code>SWIFTUI_PROFILE</code> compiler condition, which we’ll only enable whenever we want to use our new SwiftUI-based profile view, and for all other builds, we’ll fall back to our previous UIKit-based implementation — like this:</p><pre class="splash"><code><span class="s-keyword">func</span> makeProfileViewController() -&gt; <span class="s-type">UIViewController</span> {
    <span class="s-preprocessing">#if SWIFTUI_PROFILE</span>
    <span class="s-keyword">return</span> <span class="s-type">UIHostingController</span>(rootView: <span class="s-type">ProfileView</span>())
    <span class="s-preprocessing">#else</span>
    <span class="s-keyword">return</span> <span class="s-type">ProfileViewController</span>()
    <span class="s-preprocessing">#endif</span>
}</code></pre><p>To toggle the above flag on or off, we can then either use the <code>Active Compilation Conditions</code> build setting in Xcode, or if we’re building a Swift Package Manager-based project, then we can enable it by passing <code>-Xswiftc SWIFTUI_PROFILE</code> to command line tools like <code>swift build</code>.</p><p class="info">To learn more about using feature flags, both compile-time and runtime ones, check out <a href="/articles/feature-flags-in-swift">“Feature flags in Swift”</a>.</p><p>Besides using various kinds of flags, another type of compilation condition that can be really useful is <code>targetEnvironment</code> — which lets us conditionally include a piece of code only when our app is being compiled for a given environment, such as <code>macCatalyst</code>, or the simulator. Here we’re using that feature to include a <code>DebugViewController</code> within an app’s tab bar when it’s being built for the iOS simulator:</p><pre class="splash"><code><span class="s-keyword">func</span> setupTabBarController(<span class="s-keyword">_</span> controller: <span class="s-type">UITabBarController</span>) {
    <span class="s-keyword">var</span> viewControllers = [<span class="s-type">UIViewController</span>]()

    <span class="s-preprocessing">#if targetEnvironment(simulator)</span>
    viewControllers.<span class="s-call">append</span>(<span class="s-type">DebugViewController</span>())
    <span class="s-preprocessing">#endif</span>

    controller.<span class="s-property">viewControllers</span> = viewControllers
}</code></pre><p>As the above code samples show, using compiler flags and the <code>targetEnvironment</code> condition is particularly useful when we want to strip out code that’s either debug-specific, or not quite ready to ship, while still enabling us to include that code within our main code base.</p><h2><a id="handling-platform-variations-within-cross-platform-code" href="#handling-platform-variations-within-cross-platform-code">Handling platform variations within cross-platform code</a></h2><p>Another type of situation in which compiler directives and conditional compilation can come in handy is whenever we’re working on a code base that supports multiple platforms — such as a cross-platform Swift package, or an app that runs on multiple Apple platforms.</p><p>As an example, let’s say that we’re working on a SwiftUI-based drawing app for iOS, macOS and tvOS, and that we’re looking to share as much code as possible between those three platforms. While many aspects of SwiftUIs overall API are identical across all of Apple’s platforms, which is a big advantage in situations like this, there are still platform-specific variations that we might need to handle.</p><p>For example, on iOS and macOS, SwiftUI supports adding a <code>DragGesture</code> to a given view, while that API is completely unavailable on tvOS — meaning that the following code won’t compile when building our app for that platform:</p><pre class="splash"><code><span class="s-keyword">struct</span> EditorView: <span class="s-type">View</span> {
    ...

    <span class="s-keyword">var</span> body: <span class="s-keyword">some</span> <span class="s-type">View</span> {
        <span class="s-type">CanvasView</span>().<span class="s-call">gesture</span>(<span class="s-type">DragGesture</span>().<span class="s-call">onChanged</span> { state <span class="s-keyword">in</span>
            ...
        })
        ...
    }
}</code></pre><p>To fix that problem, we could use the <code>os</code> compiler condition, which — just like the conditions we used earlier — enables us to only include a given piece of code when our app is being built for a specific platform. That, combined with the <code>#if</code> and <code>#else</code> directives, essentially lets us set up platform-specific branches within our cross-platform code — like this:</p><pre class="splash"><code><span class="s-keyword">struct</span> EditorView: <span class="s-type">View</span> {
    ...

    <span class="s-keyword">var</span> body: <span class="s-keyword">some</span> <span class="s-type">View</span> {
        <span class="s-preprocessing">#if os(tvOS)</span>
        <span class="s-type">CanvasView</span>()
        <span class="s-preprocessing">#else</span>
        <span class="s-type">CanvasView</span>().<span class="s-call">gesture</span>(<span class="s-type">DragGesture</span>().<span class="s-call">onChanged</span> { state <span class="s-keyword">in</span>
            ...
        })
        <span class="s-preprocessing">#endif</span>
        ...
    }
}</code></pre><p>However, while the above approach does work, it’s arguably a bit messy, and can easily lead to code that’s hard to both read and maintain — given that we’re mixing cross-platform and platform-specific code all within a single <code>View</code> implementation.</p><p>So instead, let’s see if we can isolate the above compilation condition a bit better. One way to do that would be to move it behind a dedicated abstraction, for example by implementing a custom modifier method for it, which could look something like this:</p><pre class="splash"><code><span class="s-keyword">extension</span> <span class="s-type">View</span> {
    <span class="s-keyword">func</span> addingDragGestureIfSupported(
        withHandler handler: <span class="s-keyword">@escaping</span> (<span class="s-type">CGPoint</span>) -&gt; <span class="s-type">Void</span>
    ) -&gt; <span class="s-keyword">some</span> <span class="s-type">View</span> {
        <span class="s-preprocessing">#if os(tvOS)</span>
        <span class="s-keyword">return self</span>
        <span class="s-preprocessing">#else</span>
        <span class="s-keyword">return</span> <span class="s-call">gesture</span>(<span class="s-type">DragGesture</span>().<span class="s-call">onChanged</span> { state <span class="s-keyword">in</span>
            <span class="s-call">handler</span>(state.<span class="s-property">location</span>)
        })
        <span class="s-preprocessing">#endif</span>
    }
}</code></pre><p>Since the above method signature doesn’t rely on any platform-specific types, but rather just <code>CGPoint</code> (which is available on all of Apple’s platforms as part of CoreGraphics), we can now freely call it within our cross-platform <code>EditorView</code>, and it’ll simply have no effect when our app is running on tvOS:</p><pre class="splash"><code><span class="s-keyword">struct</span> EditorView: <span class="s-type">View</span> {
    ...

    <span class="s-keyword">var</span> body: <span class="s-keyword">some</span> <span class="s-type">View</span> {
        <span class="s-type">CanvasView</span>().<span class="s-call">addingDragGestureIfSupported</span> { location <span class="s-keyword">in</span>
            ...
        }
        ...
    }
}</code></pre><p>Another option which can be good to keep in mind when dealing with the above kind of situation is to instead create multiple platform-specific variants of the same type. In our case, that could mean defining two separate <code>EditorView</code> types, one for tvOS and one for the other platforms, which could then be placed in two separate files. We’d then include the tvOS-specific file only within our app’s tvOS target, and the other one in the rest of our targets.</p><p>However, sometimes it might be more appropriate to check for the existence of a given module, rather than which platform that our code is being compiled for. That can be done using the <code>canImport</code> condition, which is particularly useful when we wish to extend an otherwise cross-platform API with features that rely on a framework that’s not universally available — such as <a href="/basics/combine">Combine</a> in this case:</p><pre class="splash"><code><span class="s-preprocessing">#if canImport(Combine)</span>
<span class="s-keyword">import</span> Combine

<span class="s-keyword">public extension</span> <span class="s-type">GitHubSearchService</span> {
    <span class="s-keyword">func</span> publisherForRepisitories(
        matching query: <span class="s-type">String</span>
    ) -&gt; <span class="s-type">AnyPublisher</span>&lt;[<span class="s-type">Repository</span>], <span class="s-type">Error</span>&gt; {
        ...
    }
}
<span class="s-preprocessing">#endif</span></code></pre><p>The benefit of using <code>canImport</code> in situations like the above is that we don’t need to manually keep track of what platforms that a given framework is available on, and it also becomes crystal clear that the code within that block is defining a framework-specific API.</p><h2><a id="emitting-warnings-and-errors" href="#emitting-warnings-and-errors">Emitting warnings and errors</a></h2><p>The idea of intentionally producing warnings and errors within a code base might at first seem a bit strange, but can be an incredibly useful tool in many kinds of situations — for example if we want to remind ourselves of a shortcut that we just took, or if we want to add a bit of extra verification to our release builds.</p><p>For example, let’s say that we’re working on a deep linking system for a shopping app, and that in order to quickly get something up and running, we’ve made a few somewhat risky assumptions within the code used to extract a product ID from a given URL. So to give ourselves a very prominent reminder to go back and fix that code before submitting it, we could use the <code>#warning</code> directive, which will cause a warning to be emitted every time that our app is being compiled:</p><pre class="splash"><code><span class="s-keyword">func</span> extractProductID(from url: <span class="s-type">URL</span>) -&gt; <span class="s-type">Product</span>.<span class="s-type">ID</span> {
    <span class="s-preprocessing">#warning</span>(<span class="s-string">"Needs validation. Also uses a hard-coded index."</span>)
    <span class="s-keyword">let</span> components = url.<span class="s-property">pathComponents</span>
    <span class="s-keyword">let</span> rawID = components[<span class="s-number">2</span>]
    <span class="s-keyword">return</span> <span class="s-type">Product</span>.<span class="s-type">ID</span>(rawID)
}</code></pre><p>Another option would be to use a classic <code>TODO</code>-style comment, perhaps in combination with a linter in order to turn such comments into warnings — but by using the above approach we’re guaranteed to always get a warning issued by the Swift compiler itself, which in turn decreases the chance that the above shortcut will be forgotten and that our code will accidentally be shipped as-is.</p><p>To further improve the prominence of the above type of warnings, we could also enable the <code>Treat Warnings as Errors</code> build setting for our app’s release configuration, which turns all warnings into actual build errors when we’re building our app for release — completely preventing us from shipping any unfinished code that’s been marked with a warning.</p><p>It’s also possible to tell the compiler to directly produce an error as well, by using the <code>#error</code> directive, for example in order to show exactly what data that needs to be manually filled in after generating a piece of boilerplate code using some form of template:</p><pre class="splash"><code><span class="s-preprocessing">#error</span>(<span class="s-string">"Enter your public API key here"</span>)
<span class="s-keyword">let</span> service = <span class="s-type">AmazingAPIClient</span>(apiKey: <span class="s-string">""</span>)
...</code></pre><p>We could also conditionally emit an error in order to make sure that none of our debug-specific compiler flags were accidentally enabled for release builds — like this:</p><pre class="splash"><code><span class="s-preprocessing">#if !DEBUG &amp;&amp; ENABLE_INTERNAL_TOOLS
#error</span>(<span class="s-string">"Internal tools must be disabled in RELEASE builds."</span>)
<span class="s-preprocessing">#endif</span></code></pre><p>Adding the above kinds of checks within our source code might seem a bit excessive, but especially if we’re often tweaking what flags that are enabled within what builds, it could be a good idea to add a bit of extra protection to prevent debugging code from being shipped within App Store builds.</p><a class="sponsor" href="https://try.instabug.com/swiftbysundell?utm_source=swiftbysundell&amp;utm_medium=nativeads&amp;utm_campaign=swiftbysundell-nativeads-q320-aug-10" rel="nofollow" target="_blank"><img class="main" src="/images/sponsors/instabug-image.png" alt="Instabug"><div><p class="prefix">This ad keeps all of Swift by Sundell free for everyone. If you can, please check this sponsor out, as that directly helps support this site:</p><img class="mobile" src="/images/sponsors/instabug-image.png" alt="Instabug"><p><strong><span class="name">Instabug</span>:</strong> Catch bugs as soon as they happen and see exactly why each crash occurred. With Instabug you’ll automatically receive device data, network logs, and reproduction steps with every bug and crash report. It only takes a line of code to integrate. Start your free trial now and get three free months, <strong>exclusively for Swift by Sundell readers</strong>.</p></div></a><h2><a id="conclusion" href="#conclusion">Conclusion</a></h2><p>While Swift’s compiler directives might currently be quite limited compared to what some other languages offer, they still enable us to perform a fair amount of custom compile-time checks, and to create various kinds of conditional branches within our code.</p><p>However, while each of the directives that we took a look at in this article are useful within certain kinds of situations, it’s also important not to over-use them, as each time that we introduce a conditionally compiled code block, we’re essentially adding a new variant of our app that needs to be constantly tested and maintained.</p><p>Got questions, comments or feedback? You’re always welcome to contact me either via <a href="https://twitter.com/johnsundell">Twitter</a> or <a href="/contact">email</a>.</p><p>Thanks for reading! 🚀</p></div><ul class="actions"><li class="share"><a href="https://twitter.com/intent/tweet?via=johnsundell&amp;text=%E2%80%9CUsing%20compiler%20directives%20in%20Swift%E2%80%9D&amp;url=https%3A//www.swiftbysundell.com/articles/using-compiler-directives-in-swift" rel="nofollow">Share this article on Twitter</a></li></ul><div class="related-content"><div class="float-container"><h2>More on similar topics</h2><a class="browse-all" href="/tags">Browse all content by tag</a></div><ul class="item-list grid compact"><li><a aria-label="Overriding self with a weak reference" href="/tips/overriding-self-with-a-weak-reference"><article class="tips"><span class="type">Tip</span><h1>Overriding self with a weak reference</h1></article></a></li><li><a aria-label="Omitting the return keyword" href="/tips/omitting-the-return-keyword"><article class="tips"><span class="type">Tip</span><h1>Omitting the return keyword</h1></article></a></li><li><a aria-label="Mixing enums with other Swift types" href="/articles/mixing-enums-with-other-swift-types"><article class="article"><span class="type">Article</span><h1>Mixing enums with other Swift types</h1></article></a></li></ul></div></article><a aria-label="A deep dive into Swift’s function builders" class="pagination previous" href="/articles/deep-dive-into-swift-function-builders"><b>Previous:</b> A deep dive into Swift’s function builders</a><footer><p>Copyright © Sundell sp. z o.o. 2020.</p><p>Built in Swift using <a href="https://github.com/johnsundell/publish">Publish</a>.</p><p><a href="https://twitter.com/swiftbysundell" rel="nofollow" target="_blank">Twitter</a> | <a href="/subscribe">RSS</a> | <a href="/contact">Contact</a></p></footer></body>
<html ontouchstart="" lang="en"><head><meta charset="UTF-8"><meta name="og:site_name" content="Swift by Sundell"><link rel="canonical" href="https://www.swiftbysundell.com/articles/using-compiler-directives-in-swift"><meta name="twitter:url" content="https://www.swiftbysundell.com/articles/using-compiler-directives-in-swift"><meta name="og:url" content="https://www.swiftbysundell.com/articles/using-compiler-directives-in-swift"><title>Using compiler directives in Swift | Swift by Sundell</title><meta name="twitter:title" content="Using compiler directives in Swift | Swift by Sundell"><meta name="og:title" content="Using compiler directives in Swift | Swift by Sundell"><meta name="description" content="An overview of the tools and directives that enable us to influence how our Swift code gets compiled, and what sort of situations that each of those tools might be particularly useful in."><meta name="twitter:description" content="An overview of the tools and directives that enable us to influence how our Swift code gets compiled, and what sort of situations that each of those tools might be particularly useful in."><meta name="og:description" content="An overview of the tools and directives that enable us to influence how our Swift code gets compiled, and what sort of situations that each of those tools might be particularly useful in."><meta name="twitter:card" content="summary_large_image"><link rel="stylesheet" href="/styles.css?v=56" type="text/css"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="shortcut icon" href="/images/favicon.png" type="image/png"><link rel="alternate" href="/rss" type="application/rss+xml" title="Subscribe to Swift by Sundell"><meta name="twitter:image" content="https://www.swiftbysundell.com/images/articles/using-compiler-directives-in-swift.png"><meta name="og:image" content="https://www.swiftbysundell.com/images/articles/using-compiler-directives-in-swift.png"></head><body class="item"><header><div class="wrapper"><a href="/"><img class="logo" src="/images/logo.png" alt="Swift by Sundell"></a><p>Weekly Swift articles, podcasts and tips by <span class="inline-block"><a href="https://twitter.com/johnsundell" rel="nofollow" target="_blank">John Sundell</a>.</span></p><nav><ul><li class="selected"><a href="/articles">Weekly articles</a></li><li><a href="/basics">Basics</a></li><li><a href="/podcast">Podcast</a></li><li><a href="/tips">Tips</a></li><li><a href="/videos">Videos</a></li><li><a href="/questions">Q&amp;A</a></li><li><a href="/sponsor">Sponsorship</a></li><li class="search"><a href="/search">Search</a></li></ul></nav></div></header><article class="page wrapper article"><h1>Using compiler directives in Swift</h1><div class="metadata"><ul class="tags"><li class="variant-a"><a href="/tags/compiler">compiler</a></li><li class="variant-c"><a href="/tags/language-features">language features</a></li><li class="swift-version">Swift 5.2</li></ul><span class="date">Published on 16 Aug 2020</span></div><div class="content"><p>Even though Swift has a very strong compile-time focus when it comes to how it verifies and type-checks the code that we write, it’s still primarily used to implement runtime logic.</p><p>However, sometimes we might want to perform certain checks and run other kinds of custom logic when our code is being compiled, and although Swift doesn’t (yet) include a fully-featured macro or preprocessing system, it does ship with a few built-in compiler directives and conditions that enable us to influence the compilation process in various ways.</p><p>This week, let’s take a look at a few of those compiler directives and what sort of situations that each of them might be particularly useful in.</p><a class="sponsor" href="https://try.instabug.com/swiftbysundell?utm_source=swiftbysundell&amp;utm_medium=nativeads&amp;utm_campaign=swiftbysundell-nativeads-q320-aug-10" rel="nofollow" target="_blank"><img class="main" src="/images/sponsors/instabug-image.png" alt="Instabug"><div><p class="prefix">This ad keeps all of Swift by Sundell free for everyone. If you can, please check this sponsor out, as that directly helps support this site:</p><img class="mobile" src="/images/sponsors/instabug-image.png" alt="Instabug"><p><strong><span class="name">Instabug</span>:</strong> Catch bugs as soon as they happen and see exactly why each crash occurred. With Instabug you’ll automatically receive device data, network logs, and reproduction steps with every bug and crash report. It only takes a line of code to integrate. Start your free trial now and get three free months, <strong>exclusively for Swift by Sundell readers</strong>.</p></div></a><h2><a id="flags-and-environment-checks" href="#flags-and-environment-checks">Flags and environment checks</a></h2><p>Perhaps the most commonly used Swift compiler directive is the <code>#if</code> command, which enables us to conditionally include or exclude certain code blocks when our program is being compiled.</p><p>For example, we might use that command to check if our app is currently being compiled with its <em>debug</em> build configuration, by checking if the default <code>DEBUG</code> flag is enabled. Here we’re doing just that to conditionally print a given expression only within debug builds:</p><pre class="splash"><code><span class="s-keyword">func</span> log(<span class="s-keyword">_</span> expression: <span class="s-keyword">@autoclosure</span> () -&gt; <span class="s-type">Any</span>) {
    <span class="s-preprocessing">#if DEBUG</span>
    <span class="s-call">print</span>(<span class="s-call">expression</span>())
    <span class="s-preprocessing">#endif</span>
}</code></pre><p class="info">The <code>@autoclosure</code> attribute is used above to automatically turn any expression that was passed into our <code>log</code> function into a closure, in order to avoid evaluating it within release builds. To learn more about that attribute, check out <a href="/articles/using-autoclosure-when-designing-swift-apis">“Using @autoclosure when designing Swift APIs”</a>.</p><p>While the <code>DEBUG</code> flag provides an incredibly useful way to completely remove any code that we don’t want to include in our app’s shipping binary, sometimes we might want to use slightly more granular rules when deciding what code to include or remove.</p><p>That’s when <em>custom compilation conditions</em> can come in handy, which let us define our own, completely custom flags, which can then be enabled or disabled for different targets or build configurations. For example, let’s say that we’re currently working on a new SwiftUI-based profile view for an app, and while we’re not quite ready to ship that new implementation to the App Store, we do want to include it in internal builds of our app (such as TestFlight builds).</p><p>To make that happen, let’s define a dedicated <code>SWIFTUI_PROFILE</code> compiler condition, which we’ll only enable whenever we want to use our new SwiftUI-based profile view, and for all other builds, we’ll fall back to our previous UIKit-based implementation — like this:</p><pre class="splash"><code><span class="s-keyword">func</span> makeProfileViewController() -&gt; <span class="s-type">UIViewController</span> {
    <span class="s-preprocessing">#if SWIFTUI_PROFILE</span>
    <span class="s-keyword">return</span> <span class="s-type">UIHostingController</span>(rootView: <span class="s-type">ProfileView</span>())
    <span class="s-preprocessing">#else</span>
    <span class="s-keyword">return</span> <span class="s-type">ProfileViewController</span>()
    <span class="s-preprocessing">#endif</span>
}</code></pre><p>To toggle the above flag on or off, we can then either use the <code>Active Compilation Conditions</code> build setting in Xcode, or if we’re building a Swift Package Manager-based project, then we can enable it by passing <code>-Xswiftc SWIFTUI_PROFILE</code> to command line tools like <code>swift build</code>.</p><p class="info">To learn more about using feature flags, both compile-time and runtime ones, check out <a href="/articles/feature-flags-in-swift">“Feature flags in Swift”</a>.</p><p>Besides using various kinds of flags, another type of compilation condition that can be really useful is <code>targetEnvironment</code> — which lets us conditionally include a piece of code only when our app is being compiled for a given environment, such as <code>macCatalyst</code>, or the simulator. Here we’re using that feature to include a <code>DebugViewController</code> within an app’s tab bar when it’s being built for the iOS simulator:</p><pre class="splash"><code><span class="s-keyword">func</span> setupTabBarController(<span class="s-keyword">_</span> controller: <span class="s-type">UITabBarController</span>) {
    <span class="s-keyword">var</span> viewControllers = [<span class="s-type">UIViewController</span>]()

    <span class="s-preprocessing">#if targetEnvironment(simulator)</span>
    viewControllers.<span class="s-call">append</span>(<span class="s-type">DebugViewController</span>())
    <span class="s-preprocessing">#endif</span>

    controller.<span class="s-property">viewControllers</span> = viewControllers
}</code></pre><p>As the above code samples show, using compiler flags and the <code>targetEnvironment</code> condition is particularly useful when we want to strip out code that’s either debug-specific, or not quite ready to ship, while still enabling us to include that code within our main code base.</p><h2><a id="handling-platform-variations-within-cross-platform-code" href="#handling-platform-variations-within-cross-platform-code">Handling platform variations within cross-platform code</a></h2><p>Another type of situation in which compiler directives and conditional compilation can come in handy is whenever we’re working on a code base that supports multiple platforms — such as a cross-platform Swift package, or an app that runs on multiple Apple platforms.</p><p>As an example, let’s say that we’re working on a SwiftUI-based drawing app for iOS, macOS and tvOS, and that we’re looking to share as much code as possible between those three platforms. While many aspects of SwiftUIs overall API are identical across all of Apple’s platforms, which is a big advantage in situations like this, there are still platform-specific variations that we might need to handle.</p><p>For example, on iOS and macOS, SwiftUI supports adding a <code>DragGesture</code> to a given view, while that API is completely unavailable on tvOS — meaning that the following code won’t compile when building our app for that platform:</p><pre class="splash"><code><span class="s-keyword">struct</span> EditorView: <span class="s-type">View</span> {
    ...

    <span class="s-keyword">var</span> body: <span class="s-keyword">some</span> <span class="s-type">View</span> {
        <span class="s-type">CanvasView</span>().<span class="s-call">gesture</span>(<span class="s-type">DragGesture</span>().<span class="s-call">onChanged</span> { state <span class="s-keyword">in</span>
            ...
        })
        ...
    }
}</code></pre><p>To fix that problem, we could use the <code>os</code> compiler condition, which — just like the conditions we used earlier — enables us to only include a given piece of code when our app is being built for a specific platform. That, combined with the <code>#if</code> and <code>#else</code> directives, essentially lets us set up platform-specific branches within our cross-platform code — like this:</p><pre class="splash"><code><span class="s-keyword">struct</span> EditorView: <span class="s-type">View</span> {
    ...

    <span class="s-keyword">var</span> body: <span class="s-keyword">some</span> <span class="s-type">View</span> {
        <span class="s-preprocessing">#if os(tvOS)</span>
        <span class="s-type">CanvasView</span>()
        <span class="s-preprocessing">#else</span>
        <span class="s-type">CanvasView</span>().<span class="s-call">gesture</span>(<span class="s-type">DragGesture</span>().<span class="s-call">onChanged</span> { state <span class="s-keyword">in</span>
            ...
        })
        <span class="s-preprocessing">#endif</span>
        ...
    }
}</code></pre><p>However, while the above approach does work, it’s arguably a bit messy, and can easily lead to code that’s hard to both read and maintain — given that we’re mixing cross-platform and platform-specific code all within a single <code>View</code> implementation.</p><p>So instead, let’s see if we can isolate the above compilation condition a bit better. One way to do that would be to move it behind a dedicated abstraction, for example by implementing a custom modifier method for it, which could look something like this:</p><pre class="splash"><code><span class="s-keyword">extension</span> <span class="s-type">View</span> {
    <span class="s-keyword">func</span> addingDragGestureIfSupported(
        withHandler handler: <span class="s-keyword">@escaping</span> (<span class="s-type">CGPoint</span>) -&gt; <span class="s-type">Void</span>
    ) -&gt; <span class="s-keyword">some</span> <span class="s-type">View</span> {
        <span class="s-preprocessing">#if os(tvOS)</span>
        <span class="s-keyword">return self</span>
        <span class="s-preprocessing">#else</span>
        <span class="s-keyword">return</span> <span class="s-call">gesture</span>(<span class="s-type">DragGesture</span>().<span class="s-call">onChanged</span> { state <span class="s-keyword">in</span>
            <span class="s-call">handler</span>(state.<span class="s-property">location</span>)
        })
        <span class="s-preprocessing">#endif</span>
    }
}</code></pre><p>Since the above method signature doesn’t rely on any platform-specific types, but rather just <code>CGPoint</code> (which is available on all of Apple’s platforms as part of CoreGraphics), we can now freely call it within our cross-platform <code>EditorView</code>, and it’ll simply have no effect when our app is running on tvOS:</p><pre class="splash"><code><span class="s-keyword">struct</span> EditorView: <span class="s-type">View</span> {
    ...

    <span class="s-keyword">var</span> body: <span class="s-keyword">some</span> <span class="s-type">View</span> {
        <span class="s-type">CanvasView</span>().<span class="s-call">addingDragGestureIfSupported</span> { location <span class="s-keyword">in</span>
            ...
        }
        ...
    }
}</code></pre><p>Another option which can be good to keep in mind when dealing with the above kind of situation is to instead create multiple platform-specific variants of the same type. In our case, that could mean defining two separate <code>EditorView</code> types, one for tvOS and one for the other platforms, which could then be placed in two separate files. We’d then include the tvOS-specific file only within our app’s tvOS target, and the other one in the rest of our targets.</p><p>However, sometimes it might be more appropriate to check for the existence of a given module, rather than which platform that our code is being compiled for. That can be done using the <code>canImport</code> condition, which is particularly useful when we wish to extend an otherwise cross-platform API with features that rely on a framework that’s not universally available — such as <a href="/basics/combine">Combine</a> in this case:</p><pre class="splash"><code><span class="s-preprocessing">#if canImport(Combine)</span>
<span class="s-keyword">import</span> Combine

<span class="s-keyword">public extension</span> <span class="s-type">GitHubSearchService</span> {
    <span class="s-keyword">func</span> publisherForRepisitories(
        matching query: <span class="s-type">String</span>
    ) -&gt; <span class="s-type">AnyPublisher</span>&lt;[<span class="s-type">Repository</span>], <span class="s-type">Error</span>&gt; {
        ...
    }
}
<span class="s-preprocessing">#endif</span></code></pre><p>The benefit of using <code>canImport</code> in situations like the above is that we don’t need to manually keep track of what platforms that a given framework is available on, and it also becomes crystal clear that the code within that block is defining a framework-specific API.</p><h2><a id="emitting-warnings-and-errors" href="#emitting-warnings-and-errors">Emitting warnings and errors</a></h2><p>The idea of intentionally producing warnings and errors within a code base might at first seem a bit strange, but can be an incredibly useful tool in many kinds of situations — for example if we want to remind ourselves of a shortcut that we just took, or if we want to add a bit of extra verification to our release builds.</p><p>For example, let’s say that we’re working on a deep linking system for a shopping app, and that in order to quickly get something up and running, we’ve made a few somewhat risky assumptions within the code used to extract a product ID from a given URL. So to give ourselves a very prominent reminder to go back and fix that code before submitting it, we could use the <code>#warning</code> directive, which will cause a warning to be emitted every time that our app is being compiled:</p><pre class="splash"><code><span class="s-keyword">func</span> extractProductID(from url: <span class="s-type">URL</span>) -&gt; <span class="s-type">Product</span>.<span class="s-type">ID</span> {
    <span class="s-preprocessing">#warning</span>(<span class="s-string">"Needs validation. Also uses a hard-coded index."</span>)
    <span class="s-keyword">let</span> components = url.<span class="s-property">pathComponents</span>
    <span class="s-keyword">let</span> rawID = components[<span class="s-number">2</span>]
    <span class="s-keyword">return</span> <span class="s-type">Product</span>.<span class="s-type">ID</span>(rawID)
}</code></pre><p>Another option would be to use a classic <code>TODO</code>-style comment, perhaps in combination with a linter in order to turn such comments into warnings — but by using the above approach we’re guaranteed to always get a warning issued by the Swift compiler itself, which in turn decreases the chance that the above shortcut will be forgotten and that our code will accidentally be shipped as-is.</p><p>To further improve the prominence of the above type of warnings, we could also enable the <code>Treat Warnings as Errors</code> build setting for our app’s release configuration, which turns all warnings into actual build errors when we’re building our app for release — completely preventing us from shipping any unfinished code that’s been marked with a warning.</p><p>It’s also possible to tell the compiler to directly produce an error as well, by using the <code>#error</code> directive, for example in order to show exactly what data that needs to be manually filled in after generating a piece of boilerplate code using some form of template:</p><pre class="splash"><code><span class="s-preprocessing">#error</span>(<span class="s-string">"Enter your public API key here"</span>)
<span class="s-keyword">let</span> service = <span class="s-type">AmazingAPIClient</span>(apiKey: <span class="s-string">""</span>)
...</code></pre><p>We could also conditionally emit an error in order to make sure that none of our debug-specific compiler flags were accidentally enabled for release builds — like this:</p><pre class="splash"><code><span class="s-preprocessing">#if !DEBUG &amp;&amp; ENABLE_INTERNAL_TOOLS
#error</span>(<span class="s-string">"Internal tools must be disabled in RELEASE builds."</span>)
<span class="s-preprocessing">#endif</span></code></pre><p>Adding the above kinds of checks within our source code might seem a bit excessive, but especially if we’re often tweaking what flags that are enabled within what builds, it could be a good idea to add a bit of extra protection to prevent debugging code from being shipped within App Store builds.</p><a class="sponsor" href="https://try.instabug.com/swiftbysundell?utm_source=swiftbysundell&amp;utm_medium=nativeads&amp;utm_campaign=swiftbysundell-nativeads-q320-aug-10" rel="nofollow" target="_blank"><img class="main" src="/images/sponsors/instabug-image.png" alt="Instabug"><div><p class="prefix">This ad keeps all of Swift by Sundell free for everyone. If you can, please check this sponsor out, as that directly helps support this site:</p><img class="mobile" src="/images/sponsors/instabug-image.png" alt="Instabug"><p><strong><span class="name">Instabug</span>:</strong> Catch bugs as soon as they happen and see exactly why each crash occurred. With Instabug you’ll automatically receive device data, network logs, and reproduction steps with every bug and crash report. It only takes a line of code to integrate. Start your free trial now and get three free months, <strong>exclusively for Swift by Sundell readers</strong>.</p></div></a><h2><a id="conclusion" href="#conclusion">Conclusion</a></h2><p>While Swift’s compiler directives might currently be quite limited compared to what some other languages offer, they still enable us to perform a fair amount of custom compile-time checks, and to create various kinds of conditional branches within our code.</p><p>However, while each of the directives that we took a look at in this article are useful within certain kinds of situations, it’s also important not to over-use them, as each time that we introduce a conditionally compiled code block, we’re essentially adding a new variant of our app that needs to be constantly tested and maintained.</p><p>Got questions, comments or feedback? You’re always welcome to contact me either via <a href="https://twitter.com/johnsundell">Twitter</a> or <a href="/contact">email</a>.</p><p>Thanks for reading! 🚀</p></div><ul class="actions"><li class="share"><a href="https://twitter.com/intent/tweet?via=johnsundell&amp;text=%E2%80%9CUsing%20compiler%20directives%20in%20Swift%E2%80%9D&amp;url=https%3A//www.swiftbysundell.com/articles/using-compiler-directives-in-swift" rel="nofollow">Share this article on Twitter</a></li></ul><div class="related-content"><div class="float-container"><h2>More on similar topics</h2><a class="browse-all" href="/tags">Browse all content by tag</a></div><ul class="item-list grid compact"><li><a aria-label="Overriding self with a weak reference" href="/tips/overriding-self-with-a-weak-reference"><article class="tips"><span class="type">Tip</span><h1>Overriding self with a weak reference</h1></article></a></li><li><a aria-label="Omitting the return keyword" href="/tips/omitting-the-return-keyword"><article class="tips"><span class="type">Tip</span><h1>Omitting the return keyword</h1></article></a></li><li><a aria-label="Mixing enums with other Swift types" href="/articles/mixing-enums-with-other-swift-types"><article class="article"><span class="type">Article</span><h1>Mixing enums with other Swift types</h1></article></a></li></ul></div></article><a aria-label="A deep dive into Swift’s function builders" class="pagination previous" href="/articles/deep-dive-into-swift-function-builders"><b>Previous:</b> A deep dive into Swift’s function builders</a><footer><p>Copyright © Sundell sp. z o.o. 2020.</p><p>Built in Swift using <a href="https://github.com/johnsundell/publish">Publish</a>.</p><p><a href="https://twitter.com/swiftbysundell" rel="nofollow" target="_blank">Twitter</a> | <a href="/subscribe">RSS</a> | <a href="/contact">Contact</a></p></footer></body></html>
